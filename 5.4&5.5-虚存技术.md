# 5.4&5.5 虚拟内存管理技术

[TOC]

* 在内存不够用的情况下，可以采用覆盖技术和交换技术，但是：
  * 覆盖技术：需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加了程序员的负担
  * 交换技术：以进程作为交换的单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销
* 解决方案：虚拟内存管理技术



### 虚存技术

* 目标：
  * 像覆盖技术一样，不是把程序的所有内容放在内存中，因而能够运行比当前的空闲内存空间更大的程序，但是**由操作系统完成，不需要程序员设计**
  * 像交换技术一样，能够实现进行在内存与外存之间的交换，因而可以得到更多的空闲内存空间。但是做得更好，**只对进程的部分内容在内存和外存之间进行交换**



### 程序的局部性原理

* **程序的局部性原理（principle of locality）**：指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址分别局限在一定区域

  * **时间局部性**：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时间内
  * **空间局部性**：当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小的区域内

  > 程序的局部性原理表明，从理论上来说，虚拟存储技术是能够实现的，而且在实现了以后是能够取得一个满意的效果的

* 程序如果具有时间局部性和空间局部性，就认为局部性很好，这种情况下执行效率就很高；操作系统可以利用程序局部性实现高效的虚拟内存管理

* 实例：程序的编写方法对缺页率的影响

  > 例：已知页面大小为4K，分配个每个进程的物理页面数为1。现在在一个进程中，定义了如下的二维数组`int A[1024][1024]`，该数组按行存放在内存中，每一行存放在一个页面中
  >
  > ```C
  > //程序编写方法1：
  > for(j=0; j<1024; j++)
  >     for(i=0; i<1024; i++)
  >         A[i][j] = 0;
  > 
  > //程序编写方法2：
  > for(i=0; i<1024; i++)
  >     for(j=0; j<1024; j++)
  >         A[i][j] = 0;
  > ```
  >
  > 1. 由于是按行存放，解法1行循环在内部，因此共发生了1024*1024此缺页中断：
  >
  > ```ascii
  > 1,2,3,…,1024,1,2,……,1024,…… 共1024组，即1024*1024
  > ```
  >
  > 2. 解法2则之发生了1024次缺页中断：
  >
  > ```ascii
  > 1,1,1,……,2,2,2,……,……3,3,…… 缺页中断发生在1，2之间或2,3之间等，共1024次
  > ```

  * 程序具有局部性，操作系统才能实现高效的虚存管理！



### 基本概念

* 可以在页式或者段式内存管理的基础上实现：

  1. 在装入程序时，不必将其全部装入到内存，只需要将当前需要执行的部分页面或段装入内存，就可以让程序开始执行

  2. 在程序执行过程中，如果需要执行的指令或者需要访问的数据不在内存中（缺页异常或者缺段异常），处理器会通知操作系统将需要的页或者段调入内存中，然后继续执行

  3. 另一方面，操作系统将内存中暂时不适用的页面或者段调出保存在外存中，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段

     > 选择将哪部分移出到外存很重要



### 基本特征

* **大的用户空间**：

  * 通过物理内存与外存结合，提供给用户的虚拟内存空间通常大于实际的物理内存，实现了这两者的分离

    > 如32位的虚拟地址理论上可以访问4GB，而可能计算机上只有256M的物理内存，但硬盘容量大于4GB

    > **操作系统内核常驻内存！**

* **部分交换**：

  * 与交换技术相比，虚拟存储的调入和调出是对部分虚拟地址空间进行的，粒度按页或者段，开销减少，效率更高

* **不连续性**：

  * 物理内存分配的不连续性，虚拟地址空间使用的不连续性



### 虚拟页式内存管理

* 大部分虚拟存储技术都采用虚拟页式存储管理技术，即在页式管理的基础上，**增加了请求调页和页面置换功能**



##### 基本思路

> 另见[基本概念](#基本概念)

1. 当一个用户程序要调入内存运行时，不是将该程序的所有页面都装入内存，而只是装入部分页面，就可以启动程序运行

2. **请求调页**：在运行过程中，发现要运行的程序或者要访问的数据不在内存中，则向系统发出缺页中断请求，系统处理这个中断时，将外存中相应的页面调入内存，使得程序继续运行
3. **页面置换**：程序执行过程中，内存被占用越来越多，会将部分暂时不执行的程序/不访问的数据换出内存



##### 页表表项

> 参考第四章分页中的页表

```ascii
逻辑页号
|                          修改位            驻留位
▼ ┌─────────────────┐─────┐──┼──┐──────────┐──┼──┐───────────────┐
i │                 │  ▲  │  ▼  │    ▲     │  ▼  │       ▲       │
  └─────────────────┘──┼──┘─────┘────┼─────┘─────┘───────┼───────┘
                     访问位          保护位              物理页帧号
```

* **页表**表项最主要存贮物理帧号

* 为了进行虚拟内存管理的`flag`位：

  1. **驻留位**：表示该页在内存还是外存

     > 为1，该页在内存中可以使用；为0，表示该页在外存中，如果访问该页表项会产生缺页中断

  2. **保护位**：表示运行对该页进行何种类型的访问

     > 包括只读/读写/可执行
     >
     > 如果只读的状态，尝试写操作会出错

  3. **修改位**：表明此页是否被修改过（是否进行了`写`操作）

     > **有效提高置换功能的效率！**

     > * 1表示修改过，0表示没有修改过
     >
     > * 当系统回收该物理页面时，根据此位来决定是否把它的内容写回内存：
     >   * 如果没有修改过，置换时直接释放就行，因为此时内存中和硬盘中的内容是一致的，下次使用时再从硬盘中调用就好了
     >   * 如果被修改过，则内存中数据和外存中数据不一致，进行页面置换的时候就需要将修改过的数据重新写回外存即硬盘中

  4. **访问位**：表示此页最近是否被访问过

     > * 如果该页面被访问过（读/写），则设置此位为1，否则为0
     >
     > * 用于**页面置换算法**（长久没有被访问就说明应该置换去外存）



##### 缺页中断处理过程

> 当CPU执行一条指令，`load`对应的地址，如果对应的地址`存在位`为`0`，则产生`缺页异常`，然后进行以下一系列的工作：

1. 如果内存中有空闲的物理页面，则分配一物理帧`f`，然后转到第4步，否则转到第2步

2. 采用某种**页面置换算法**，选择一个将被替换的物理页帧`f`，它所对应的逻辑页号为`q`，如果该页在内存期间被修改过，则需要把它写回外存

   > 根据修改位判断是否修改过，如果`q`没有被修改过，则直接释放，因为硬盘和内存中的内容相同
   >
   > 参见[页表表项](#页表表项)中的**修改位**

3. 对`q`所对应的页表项进行修改，将驻留位置改为`0`

   > 表明`q`此时不在物理内存中了

4. 将需要访问的页`p`装入到物理帧`f`中

   > `p`中的内容原本存储在磁盘上的虚拟内存中，重新装入到物理内存中

5. 修改`p`对应的页表项内容，把驻留位改为`1`，将物理帧号置为`f`

   > 更新页表项，将`p`和`f`的映射保存到页表项中

6. 重新运行被中断的指令



##### 后备存储

> 这部分没咋听懂啥意思（= =）

* 在何处保存未被映射的页？
  * 能够简单地识别在二级存储器中的页
  * 交换空间（磁盘或文件）：特殊格式，用于存储未被映射的页面

* 概念：**后备存储（Backing Store）**
  * 一个虚拟地址空间的页面可以被映射到一个文件（在二级存储中）中的某个位置
  * 代码段：映射到可执行二进制文件
  * 动态加载的共享库程序段：映射到动态调用的库文件
  * 其它段：可能被映射到交换文件（swap file），由OS开辟的空间



##### 虚拟内存的性能

* 为了便于理解分页的开销，使用**有效存储器访问时间（effective memory access time）**

* `EAT` = `访存时间` * `页表命中几率` + `page fault处理时间` *` page fault几率` *`（1 + dirty page概率）`

  >* `EAT`代表了平均访问的时间
  >* `访存时间`：内存的访问时间
  >* `页表命中几率`：页表中`驻留位`为`1`的比例，注意`页表命中几率 + page fault几率 = 1`
  >* `page fault处理时间`：硬盘的访问时间，发生`page fault`即证明该页没有对应的帧，需要从硬盘中加载到内存中
  >* ` page fault几率`：发生缺页的几率，等于`1-页表命中几率`
  >* `dirty page概率`：页表中修改位`为`1`的比例，即某页被修改过，因而页面置换时需要进行硬盘的写操作

  >例子：
  >
  >内存访问时间：10ns
  >
  >磁盘访问时间：5ms
  >
  >参数p ：page fault几率（产生缺页的概率，因此需要进行硬盘访问）
  >
  >参数q：dirty page几率（页面置换需要写入硬盘的概率）
  >
  >`EAT=10*(1-p)+5000000*p*(1+q)`