# 5.1 虚拟内存的起因

### 存储器

* 理想中的存储器：更大、更快、更便宜的**非易失性**存储器

* 实际中的存储器：

  ```ascii
                               存储器层次结构
  
  Typical accsess time                                     Typical capacity
                              ┌-----------┐ 
  1 nsec                      | Registers |                    < 1 KB
                             ┌--------------┐
  2 nsec                     |    Cache     |                    1 MB
                           ┌-------------------┐
  10 nsec                  |   Main Memory     |                64-512 MB
                        ┌--------------------------┐
  10 msec               |     Magnetic Disk        |             5-50 GB
                     ┌---------------------------------┐
  100 sec            |         Magnetic Tape           |         20-100 GB
                     └---------------------------------┘
  ```

  > 如何把硬盘的容量也用上？
  >
  > 如果这些层次结构仅靠编程人员来管理，其实是非常困难的，因此希望操作系统能够从中协助，实现一个更大的更快更便宜的虚拟的存储空间。

  <img src=".\pics\vm1.png" alt="OS抽象：地址空间" style="zoom:125%;" />

> 在 OS Kernel管理下，同时运行很多程序，光靠内存是不够的，因此把常用的代码或数据放到内存中，而不常用的放到硬盘中（需要CPU中的MMU和Kernel共同协作）



### 内存不足

* 在计算机系统中，尤其是在多道程序运行的环境下，可能会出现内存不足的情况，该如何处理？

  1. 如果程序太大，超过了内存的容量，可以采用**手动的覆盖（overlay）技术**，只把需要的指令和数据保存在内存当中

     > 比较早期的技术

  2. 如果程序太多，超过了内存的容量，可以采用**自动的交换（swapping）技术**，把暂时不能执行的程序送到外存中

     > 在3.4节连续内存分配的交换式碎片整理中提到过，这种交换技术的**粒度**是单个程序
     >
     > 由于每次需要移动整个程序的内容，频繁的交换，开销很大

  3. 如果想要在有限容量的内存中，以**更小的页粒度**为单位装入更多更大的程序，可以采用自动的**虚拟存储技术**

     > 基于分页分段，通过OS的管理将数据与代码按页/段导入导出内存，将**粒度**从`单个程序`改为`段`或者`页`