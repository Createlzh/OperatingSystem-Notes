# 7.1-7.7 进程

[TOC]

### 进程的定义

* **进程**：一个具有一定独立的功能的**程序**在一个数据集合的一次**动态执行过程**

* **程序**：程序是静态的

  > 源码通过编译与连接得到的可执行文件，仍是静态的
  >
  > 把它加载到内存中，通过CPU执行程序中的一条条指令才是一次动态执行过程



### 进程的组成

* 程序的代码
* 程序处理的数据
* 程序计数器（寄存器中的值），指示下一条将运行的指令
* 一组通用的寄存器的当前值，栈，堆；
* 一组系统资源（包括打开的文件，内存，网络等等）

> 总之，进程包含了正在运行的一个程序的所有状态信息



### 进程与程序的联系

- 程序是产生进程的基础：

  > 程序的代码指定限制了进程完成的功能。

- 程序的每次运行构成不同的进程：

  > 程序只有一份，但是可以多次执行，虽然程序代码一样，但是进程处理的数据、获得的资源不一样，最后执行的效果也可能不一样

- 进程是程序功能的体现

  > 虽然输入的不同可能导致输出的不同，但功能体是一致的

- 进程与程序是多对多的关系：

  - 一个程序可以对应多个进程；
  - 通过调用关系，一个进程可以包括多个程序



### 进程与程序的区别

- 程序是静态的，进程是动态的

- 程序是代码的集合，进程是程序的执行，进程具有核心态/用户态

  > 进程在执行过程中，有些特定功能需要操作系统提供，进程向OS发出请求，OS代表进程在内核中执行

- 程序是永久的，可以长久保存；进程是暂时的，进程是一个状态变化的过程

- 进程与程序组成不同：进程包含了程序，数据和进程控制块（即进程状态信息）

* 实例：

  > ![进程与程序的关系：类比1](.\pics\jincheng1.png)



### 进程的特点

1. **动态性**：可动态地创建，结束进程

2. **并发性**：进程可以被独立地调度并占用CPU执行

   > - **并发**：一段时间内有多个进程在执行，
   >
   >   > 一个CPU一个时刻只能执行一个进程，但是一小段时间内CPU可以调度执行多个进程，看起来就像很多进程在一起执行
   >
   > - 并行：一个时刻有多个进程在执行，需要多个CPU才能进行并行

3. **独立性**：不同进程的工作不互相影响

   - 进程的执行时间可能会被别的进行影响
   - 但是进程的正确性不会受影响：数据，指令不会被影响，最终运行结果也不受影响
   - OS通过页表，使得不同应用程序访问不同的地址空间，当应用程序访问越过其自身的地址空间时，会产生缺页异常、页错误

4. **制约性**：因访问共享数据/资源或进程间同步产生制约

   > 比如一个进程需要另一个进程完成后才能继续执行



### 进程控制结构

* **进程控制块**：`PCB`（Process Control Block）

  > 程序=算法+数据结构，PCB就是描述进程的数据结构

  * 操作系统管理控制进程运行所用的信息集合
  * OS为每个进程维护了一个`PCB`，来描述进程的基本情况以及运行变化的过程
  * `PCB`是进程存在的唯一标志，进程与`PCB`一一对应，同时创建，同时结束

* **使用进程控制块**：
  * 进程的创建：为该进程生成一个`PCB`
  * 进程的终止：回收它的`PCB`
  * 进程的组织管理：通过对`PCB`的组织管理来实现

* **进程控制块的三大类信息**：

  1. 进程**标识信息**

     > 如本进程的标识，本进程的产生者标识（父进程标识），用户标识

  2. 处理机**状态信息**保存区：保存进程的运行现场信息

     * 用户可见寄存器：用户程序可以使用的数据，地址等寄存器。
     * 控制和状态寄存器：如程序计数器，程序状态字（PSW）
     * 栈指针：过程调用/系统调用/中断处理和返回时需要用到它

  3. 进程**控制信息**：

     * 调度和状态信息：用于操作系统调度进程并占用处理机

       > 不同状态体现进程的执行现状，如占用CPU运行的状态、等待的状态、就绪的状态

     * 进程间通信信息：为支持进程间与通信相关的各种标识，信号，信件等

       > 这些信息存在接收方的进程控制块中

     * 存储管理信息：包含有指向本进程映像存储空间的数据结构

     * 进程所用资源：说明由进程打开、使用的系统资源

       > 如打开的文件等

     * 有关数据结构连接信息：进程可以连接到一个进程队列中，或连接到相关的其它进程的PCB

* PCB的组织方式：

  1. 链表：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表

     > 如就绪链表，阻塞链表等

  2. 索引表：同一状态的进程归入一个index表（由index指向PCB），多个状态对应多个不同的index表

     > 如就绪索引表

  * 链表形式可以更好地完成动态的插入和删除，而索引表的开销更大
  * 一般情况下选用链表
  * 如果进程比较固定，可以采用索引表



### 进程的生命周期

> 创建 - 运行 - 等待 - 唤醒 - 结束

1. **进程的创建**：

   * 引起进程创建的三个主要事件：

     * 系统初始化时，`init`进程的创建

       > `init`进程再负责创建其他的进程

     * 用户请求创建一个新的进程

     * 正在运行的进程执行了创建进程的系统调用

   * 在内存中构建一个PCB，完成基本的初始化，形成一个新的进程

2. **进程的运行**：

   * 操作系统内核选择一个可以执行的进程，让它让占用CPU并执行，变成“运行态”

     > 可以执行的进程称为**就绪态**

   * OS的调度算法决定何时选择，如何选择

3. **进程的等待**：

   * 以下情况，进程等待（阻塞）

     - 请求并等待系统服务，无法马上完成

       > 比如磁盘文件读入内存中时，读的速度相对于CPU的执行速度来说很慢，为了不占用CPU，这个进程应该选择等待操作系统把文件读入内存中来

     - 进程要启动某种操作，现在无法马上完成

       > 比如要等等别的进程的结果

     - 需要的数据没有到达

       > 比如等待网络数据包

   * **进程只能自己阻塞自己**，因为只有进程自身才能知道何时需要等待某种事件的发生

     > 因为别的进程和OS不会了解进程需要进行的操作

4. **进程的唤醒**：

   * 进程被唤醒的原因：
     * 被阻塞进程需要的资源可以被满足
     * 被阻塞进程等待的事件到达
     * 将该进程的PCB插入到就绪队列
   * **进程只能被别的进程或操作系统唤醒**

5. **进程的结束**：

   * 正常退出（自愿）

   * 错误退出（自愿）

   * 致命错误（强制性的）

     > 比如去访问其他进程的地址空间，就会被操作系统系统杀死

   * 被其它进程杀死（强制性的）

     > 比如一些管理进程认为某进程占用内存太多，破坏了整个系统的安全和可靠性，就会杀死该进程



### 进程状态变化模型

> 不同系统设置的进程状态数目不同

* 进程的三种基本状态：

  > 一个进程在生命结束以前，处于且仅处于三种基本状态之一

  1. 运行状态（running）：当一个程序正在CPU上运行时

  2. 就绪状态（Ready）：一个进程获得了除CPU以外的一切资源，一旦得到CPU资源即可运行

  3. 等待状态（又称阻塞状态Blocked）：一个进程正在等待某一事件而暂停运行时

     > 如等待某资源，等待输入/输出完成

* 进程其他的基本状态：

  * 创建状态（new）：一个进程正在被创建，还没有转到就绪状态之前的状态

  * 结束状态（exit）：一个进程正在从系统中消失的状态，因为进程结束或者其他原因所导致的

    > 结束状态下PCB还存在，只有PCB消失之后进程才彻底结束

* 状态变化图：

  ![状态变化图](.\pics\jincheng2.png)

  > 进程从就运行态变成就绪态的原因：内存很大而CPU少，内存中存在多个不同的就绪进程，我们希望每个进程都有机会去执行，给每个就绪进程分配一个小的**时间片**，当就绪进程被CPU执行完一个时间片之后，就被切换下来，让其他就绪态进程被执行

* 可能的状态变化如下：

  * `Null`到`New`：一个新进程被产生出来执行一个程序，PCB被创建，完成PCB的初始化过程

  * `New`到`ready`：进程创建完成初始化后，一切就绪准备运行时，变为就绪态

    > PCB中的数据结构被初始化完毕，进程可以执行了：这个过程很短，因为只是完成PCB初始化的过程

  * `Ready`到` Running`：就绪态的进程被进程调度程序选中后，分配到CPU运行

    > 如何选取决于调度算法

  * `Running`到`Exit`：当进程表示它已经完成或者出错，当前运行进程会由操作系统作结束处理

  * `Running`到`Ready`：处于运行状态的进程在其运行过程中，由于分配给它的处理机**时间片**用完而让出处理机

    > 这是由操作系统完成的，操作系统还管理着时钟

  * `Running`到`Blocked`：当进程请求某样东西且必须等待时

    > 如等待一个定时器的到达，或者读写文件

  * `Blocked`到`Ready`：当进程要等待某事件到来时，它从阻塞状态变到就绪状态

    > 唤醒是由操作系统或者其他进程完成的



### 进程挂起

* 进程挂起：
  * 为了合理且充分地利用系统资源
  * 挂起的进程没有占用内存空间，处在挂起状态的进程映像在磁盘上

* 进程挂起两种状态：

  1. 阻塞挂起状态（Blocked-suspend）：进程在外存中并等待某事件的出现

     > 进程本身处于阻塞状态

  2. 就绪挂起状态（Ready-suspend）：进程在外存中，但只要进入内存即可运行

     > 进程本身处于阻塞状态

* **与挂起相关的状态转换**：

  * **挂起（Suspend）**:把一个进程从内存转到外存

    1. 阻塞到阻塞挂起

       > 没有进程处于就绪状态或者就绪进程要求更多的内存资源时，就会进行这种转换，以提交新进程或者运行就绪进程

    2. 就绪到就绪挂起

       > * 一般情况下下，就绪状态的进程优先级大于阻塞状态的进程，所以一般会先将阻塞状态的进程挂起
       >
       > * 但当有高优先级阻塞（系统认为会很快唤醒就绪的）进程和低优先就绪进程时，系统就会选择挂起低优先就绪进程

    3. 运行到就绪挂起

       > 对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而成为就绪挂起时，系统可能会把运行进程转到就绪挂起状态

  * **在外存时的状态转换**：

    * 阻塞挂起到就绪挂起：当有阻塞挂起进程**因相关**事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程

      > 相关事件出现，阻塞被唤起，但进程本身资源和数据仍然在外存中

  * **解挂/激活（activate）**：把一个进程从外存转化到内存

    1. 就绪挂起到就绪

       > 没有就绪进程或者挂起就绪进程优先级高于就绪进程时，会进行

    2. 阻塞挂起到阻塞

       > 当一个进程释放足够内存时，系统会将一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转换为阻塞进程



### OS管理PCB完成进度调度

> OS如何通过PCB和定义的进程状态来管理PCB，帮助完成进程的调度过程？

* OS要选择某个进程占用CPU执行
* OS需要选择对某个进程如何进行状态转换

* **状态队列**：

  * 由OS维护一组队列，用来表示系统当中所有进程的当前状态

  * 不同状态分别用不同的队列来表示（就绪队列，各种类型的阻塞队列）

  * 每个进程的PCB都根据它的状态加入相应的状态队列， 当一个进程的状态发生改变时，它的PCB就从一个状态队列中脱离出来，加入到另外一个状态队列

    > 状态队列是操作系统管理过程中重要的数据结构，把不同进程对应的PCB组织起来，便于管理

  * 图示：

    ![状态队列表示](.\pics\jincheng3.png)

    > 状态队列也分优先级，比如多个就绪队列优先级不同，阻塞队列按照等待事件也分为多个队列

