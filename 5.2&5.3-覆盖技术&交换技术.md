# 5.2&5.3-覆盖技术&交换技术

### 覆盖技术

* **目标**：在较小的可用内存中运行较大的程序

  > 较小和较大是相对的
  >
  > 常用于多道程序系统，与分区的存储管理配合使用

* **原理**：把程序按照自身逻辑结构，划分为若干个功能上相对独立的程序模块，不会同时执行的模块共享同一块内存区域，按照时间先后顺序来运行

  > 不会同时执行的不同模块，以分时的方式共享同一块内存空间

  * 必要部分（常用功能）

    > 必要部分（常用功能）的代码和数据常驻内存
    >
    > 其中一定会有一块代码，负责管理、决定何时哪一块代码或数据进入内存

  * 可选部分（不常用功能）

    > 不常用功能，在其他程序模块中实现，平时放在外存中，在需要的时候才装入内存

  * 不存在调用关系的模块不必同时装入到内存中，从而可以相互覆盖，即这些模块共用一个分区

    > 有多种不同的分配区的方式，见下方实例

* 一个实例

  > ![覆盖技术实例](.\pics\vm2.png)
  >
  > * `A`要负责调用`B`和`C`，必须放在`常驻区`
  > * `B`和`C`相互之间没有调用关系，因此分在一个覆盖区`0`
  > * 同理，`D`、`E`和`F`也可以分在一个分区`1`
  > * 当`C`调用`E`时，`D`和`F`都不需要放在区`1`内
  > * 当`C`需要调用`F`时，再将`F`载入到覆盖区`1`
  > * 这种方法需要的内存：20K+50K+40K=110K
  > * 另一种覆盖方法（100K）：
  >   * `A`占一个分区：20K
  >   * `B`和`E`、`F`共用一个分区：50K
  >   * `C`和`D`共用一个分区：30K

* 缺点：

  * 设计的开销：要由程序员将大的程序划分为若干小的功能模块，并确定各个模块之间的覆盖关系，费时费力增加了编程的复杂度

  * 时间开销：覆盖模块从外存装入内存，实际上是以时间来换取空间节省

    > 在不同的执行阶段，要不停的换入换出，涉及到硬盘的频繁读写，要从外存装入内存或者从内存换出到硬盘



### 交换技术

* **目标**：多道程序在内存中时，让正在运行的程序或者需要运行的程序获得更多的内存资源

* **方法**：

  * 可将暂时不能运行的程序送到外存中，从而获得空闲内存空间

  * 操作系统把一个进程的整个地址空间的内存保存在外存中（**换出 swap out**），而将外村中的某个进程的地址空间读入到内存中（**换入 swap in**）：换入换出内容的大小为整个进程的地址空间

    > 导入导出的过程是内存管理的重要组成部分

    > **粒度是一个程序**，如果程序比较大则开销就很大，通常比分页的方法大很多

  <img src=".\pics\vm3.png" alt="交换技术" style="zoom:125%;" />

* 交换技术实现中的几个问题：

  * 交换时机的确定：何时需要发生交换？

    * 只当内存空间不够或者有不够的危险时换出

    > 硬盘的速度和内存的速度差了好几个数量级，每次交换都得等硬盘，频繁交换会影响系统

  * 硬盘上专门划出一个区叫**交换区**，交换区的大小？

    * 必须足够大以存放所有用户进程的所有内存映像的拷贝
    * 必须能对这些内存映像进行直接存取

  * 程序换入时的重定位？

    * 换出后再换入的内存地址可能和原位置不一致，最好采用动态地址映射的方法

      > 换出后，等再次换入时可能原来的位置已经被占用了

* **交换技术对程序员是透明的：**

  * 交换在操作系统内部完成

  * 程序员不需要了解什么时候换出什么时候换入

    > 这一点和覆盖技术不一样！



### 覆盖技术与交换技术的对比

* **目标一致**：较大/更多的程序运行在有限的内存里

* **范围不一致**：
  * 覆盖：发生在一个程序里，涉及到一个程序中没有调用关系的函数或者模块，粒度是一个模块
  * 交换：发生在程序之间，粒度是单个程序
* **代价不一样**：
  * 覆盖：
    * 粒度是一个模块，开销相对小
    * 程序员需要手动指定程序里的逻辑关系，便于覆盖的处理单元能够正常完成相应的功能
  * 交换：
    * 每次换入换出一个程序，开销比较大
    * 操作过程在内部完成，不需要程序员做出前期的设置，减轻了程序员的负担

