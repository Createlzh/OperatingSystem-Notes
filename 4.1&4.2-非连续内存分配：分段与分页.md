# 4.1&4.2 非连续内存分配：分段与分页

### 非连续内存分配

* 两种方法：

  1. 分段（Segmentation）

  2. 分页（Paging）

     * 页表（Page Table）

* **连续内存分配**的**缺点**：

  1. 物理地址空间是连续的
  2. 内存利用率低
  3. 有内碎片，外碎片的问题

* **非连续内存分配**的**优点**：

  1. 一个程序的物理地址空间是非连续的
  2. 更好地利用和管理内存
  3. 允许共享代码与数据（如共享库）
  4. 支持动态加载和动态链接

* **非连续内存分配**的**缺点**：

  - 管理开销本身：如何建立虚拟地址与物理地址之间的转换？

    - 软件方案：开销相当大

    - 硬件方案

      1. 分段

      2. 分页



### 分段

##### 程序的分段地址空间

* 程序由各个段组成

  > 主程序，子程序，共享的库

* 数据也有很多段

  > 栈段，堆段，共享数据段，

* **分段**：不同段属性不同，如果能够有效区别隔离不同的顶端，有助于更好的管理程序

  ![分散到多个物理地址空间](.\pics\segmentation1.png)

  > 左边是连续的虚拟地址，右边是不连续的物理地址

  ![分段的逻辑视图](.\pics\segmentation2.png)



##### 分段寻址方案

> 如何通过硬件方案，让一维的逻辑地址对应上物理地址？

* **段访问机制**：

  > 段：一个内存“块”，一个逻辑地址空间

  * 程序访问内存地址需要：一个二维的二元组`(s, addr)`

    * `s`：段号
    * `addr`：段内偏移

  * 段机制的两种实现方案：

    1. 段寄存器+地址寄存器实现方案

       > 段号和段内地址分开存储

    2. 单地址实现方案

       > 合并起来，单独一个地址

* 利用**段机制**实现硬件方案：

  <img src=".\pics\segmentation3.png" alt="分段硬件实现方案" style="zoom:125%;" />

  * 可运行应用程序通过CPU运行指令，CPU要寻址（找寻数据、代码），逻辑地址分为`(s, addr)`段号+段内偏移

  * **段表**：以段号为索引index，同时存储了不同段在物理内存中的起始地址和长度限制
  * 通过以逻辑地址的段号为索引，在段表中找到对应的项，也就获取了相应的物理地址
  * CPU通过比对段的长度限制和段内偏移，判断是否异常，如果非法则`kill`相应的程序
  * 如果寻址和长度合法则取出相应地址的数据，交与CPU进一步处理

* **段表在寻址之前，就在操作系统中建立了，保证了段机制的运行！**



### 分页

* 分页与分段的**最大区别**：分段中段的长度是可变的，但是页的大小是固定不变的！

* **分页的实现**：

  * 物理内存：划分至固定大小的**帧`Frame`**

    >  大小是2的幂：512，4096，8192

  * 逻辑地址空间：划分至相同大小的**页`Page`**

  * 建立方案，转换逻辑地址为物理地址`pages to frames`

    * 页表
    * `MMU`内存管理单元/`TLB`块表：加速地址的转换

* **帧（Frame）**：

  * 物理内存被分割为大小相等的页帧

  * 一个内存物理地址是一个二元组`(f, o)`

    * `f`：帧号（F位，共有`2^F`个帧）

      > 注意是二进制表示的，F位的意思是F个0或1组成帧号，共有2^F个帧

    * `o`：帧内偏移（S位，每帧有`2^S`个字节）

      > 同理，S位的意思是S个0或1组成帧号，因此每帧有2^S个字节

    * 物理地址：`2^S * f + o`

* 物理地址计算的实例：

  > 16-bit的地址空间，9-bit（512）大小的页帧：`0000011000000110`
  >
  > > 页帧是9bit即有九位，S=9，则前7bit是帧号，F=7
  > >
  > > 且帧号为`0000011`=3，帧内偏移为`000000110`=6
  > >
  > > 因此物理地址 = (3, 6)
  > >
  > > 所以物理地址 = 2^9 * 3 + 6 = 1542

* **页（Page）**：
  * 一个程序的逻辑地址空间被划分为大小相等的页
  * 一个逻辑地址是一个二元组`(p, o)`
    * `f`：页号（P位，共有`2^F`个页）
    * `o`：页内偏移（S位，每帧有`2^S`个字节）
    * 虚拟地址：`2^S * p + o`

* **帧号和页号也许不一样，但是每个帧的长度和页的长度一定相同，不是所有的页都有对应的帧！**

  > `F`未必等`P`，但是`S(frame)`一定等于`S(page)`
  >
  > 见下方内容



##### 页寻址机制

​	<img src=".\pics\page1.png" alt="页寻址机制" style="zoom:125%;" />

* 可运行应用程序通过CPU运行指令，CPU要寻址（找寻数据、代码），逻辑地址分为`(p, o)`页号+页内偏移

* **页表**：一个大数组，以段号（page number）为索引index，存储了帧号（frame number）
* 通过以逻辑地址的**页号p为索引**，在段表中找到对应**页表项**，也就是获取相应的帧号`f`
* 利用`f`页帧号与`o`偏移值组成物理地址

* **注意：页表由操作系统建立，在使用分页机制之前就建立好了！**

![页寻址机制2](.\pics\page2.png)

* 页映射到帧

* 页是**连续**的逻辑内存

* 帧是**非连续**的物理内存：**有助于减少内存碎片**

* 不是所有的页都有对应的帧！

  > 磁盘上虚拟内存大于实际的物理内存