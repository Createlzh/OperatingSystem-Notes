# 2.2 操作系统中断/异常/系统调用

[TOC]

### 定义

* **系统调用**（来源于应用程序）：应用程序主动向操作系统发出服务请求

* **异常**（来源于不良的应用程序）：非法指令或者其他坏的处理状态，如内存出错

  > 异常不是应用程序主动的操作，而系统调用是主动的

* **中断**：来自不同的硬件设备的计时器和网络的中断



### 三者对比

1. 源头：
   * 系统调用：应用程序请求操作提供服务
   * 异常：应用程序意想不到的行为
   * 中断：外设

2. 处理时间：

   * 系统调用：异步或同步
   * 异常：同步
   * 中断：异步

   > 同步：发出一个请求，立即处理后才能继续
   >
   > 异步：发出请求后被动等待处理

   > 参考CSDN博客[进程同步/异步的区别](https://blog.csdn.net/qq_43185391/article/details/93401528)
   >
   > **进程同步**：这是进程间的一种**运行关系**。“同”是协同，按照一定的顺序协同进行（**有序进行**），而不是同时。即**一组**进程为了协调其推进速度，在某些地方需要相互等待或者唤醒，这种**进程间的相互制约**就被称作是进程同步。
   >
   > **进程异步**：异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，**通过状态、通知和回调来通知调用者**。
   >
   > **同步是指两个进程的运行是相关的，其中一个进程要阻塞等待另外一个进程的运行。异步的意思是两个进程毫无相关，自己运行自己的。**

3. 响应：
   * 系统调用：等待和持续（等待服务完成后就继续了，不会重复执行刚刚的调用请求）
   * 异常：杀死或者重新执行意想不到的应用程序指令
   * 中断：持续，对用户应用程序是透明的（由操作系统完成，用户感知不到）



### 中断的处理

* **硬件**：设置中断标记（CPU初始化）

  * 将内部、外部事件设置中断标记

  * **中断事件的ID**

    > 发给操作系统根据中断号去找到对应的中断处理例程

* **软件**：

  * 保存当前处理状态：保存当前被打断程序的执行现场

  * 中断服务程序处理

    > 根据中断号，跳到相应的中断处理例程的地址

  * 清除中断标记

  * 恢复之前保存的处理状态

    > 让应用程序完全不知情的情况下继续执行，即对应用程序透明



### 异常的处理

* 保存现场

  * 产生异常的指令，产生异常的地址，当前寄存器的内容

* 异常处理：根据**异常编号**处理

  * 杀死产生了异常的程序

  * 或者重新执行异常指令

    > 操作系统认为产生异常是”服务“不到位，弥补好可以继续执行

* 恢复现场

  > 由于已经操作系统缺陷弥补好了，所以重新执行时不会出现异常，应用程序不知情，因此同样是对应用程序透明的



### 系统调用的处理

* **程序访问主要是通过高层次的API接口而不是直接进行系统调用**：

  > Win32 API用于Windows
  >
  > POSIX API用于POSIX-based systems（包括UNIX，LINUX，Mac OS X的所有版本）
  >
  > Java API用于JAVA虚拟机JVM

  > **为什么应用程不能直接访问外设，而是需要通过操作系统？**
  >
  > 1. 在计算机运行中，内核是被信任的第三方
  >
  > 2. 只有内核可以执行特权指令
  >
  > 3. 为了方便应用程序
  >    * 操作系统为上层应用提供了抽象接口，应用程序不需要关注底层设备，提高了可移植性
  * 通常情况下，与每个系统调用相关的序号，系统调用接口根据这些序号来维护表的索引
  * 系统调用接口调用内核态中预期的系统调用，并返回系统调用的状态和其他任何返回值
  * 用户不需要知道系统调用是如何实现的，只需要获取API和了解操作系统将什么作为返回结果
  * 操作系统接口的细节大部分都隐藏在API中，通过运行程序支持的库来管理（用包含编译器的库来创建函数集）



##### 系统调用的具体实现：

```shell
APP <--> Library Code <--> System Call Interface <--> Kernel
```

* 完成从**用户态**到**内核态**的转换，从而使得控制权从应用程序交到操作系统：
  * **用户态**：应用程序执行时CPU处于的特权级状态，低，不能I/O及特殊的机械指令
  * **内核态**：OS运行时CPU处于的状态，权限高，可以执行所有指令，完全控制整个计算机系统

* 操作系统对应用程序发出的**系统调用的参数、ID号**做出标识，识别之后完成具体的服务



##### 跨越操作系统边界的开销

> 除了用户态内核态，还有其他的变化：
>
> * 应用程序的函数调用在一个栈空间就完成了传参和返回
>
> * 系统调用的执行过程中，应用程序和操作系统的内核有各自的堆栈，因此需要切换堆栈
> * 切换用户态和内核态，以及堆栈的切换都会带来一定的开销，所以执行系统调用比函数调用的开销大很多，相应地安全可靠地运行

* 在执行时间上的开销超过程序调用

* 开销：

  * 建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销

  * 建立内核堆栈

    > 操作系统有自己的堆栈，不能和应用程序的堆栈混为一谈

  * 验证应用程序的参数

    > 操作系统不信任应用程序，需要对应用程序的参数新型检查

  * 拷贝数据的开销

    > 内核态映射到用户态的地址空间，更新页面映射权限

  * 内核态独立地址空间：TLB

* 额外的开销是值得的，因为更安全更可靠