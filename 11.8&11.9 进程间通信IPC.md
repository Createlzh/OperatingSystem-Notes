# 11.8&11.9 进程间通信IPC

[TOC]

___

### IPC概述

##### 通信模型

* 进程间通信`IPC`：Inter-Process Communication

* 为什么需要进程间通信：

  * 大的任务需要多个进程之间协作完成，需要数据的沟通和传递

    > 进程同步与通信的区别：进程同步是目的，而进程通信是实现手段

  * 在保证进程相互独立性的前提下，需要进程间通信

    > 内存管理很重要的一部分内容就是保证进程地址空间不会被其他不相干的进程访问

* `IPC facility`提供2个操作：

  1. `send`：消息大小固定或者可变
  2. `receive`

* 如果进程`P`和进程`Q`想通信，需要：

  1. 在它们之间建立**通信链路**
  2. 通过`send/receive`交换消息

* 通信链路的实现：

  * 物理方式（如共享内存，硬件总线）
  * 逻辑方式（如逻辑属性）



##### 直接通信

* 进程必须正确地命名对方：

  * `send(P, message)`：发送信息到进程P
  * `receive(Q, message)`：从进程Q接收消息

* 通信链路的属性：

  * 自动建立链路

    > 需要操作系统的支持，因为操作系统可以访问所有的内存和资源，因此可以建立这种通路

  * 一条链路恰好对应一对通信进程

  * 每对进程之间只有一个链接存在

  * 链接可以是单向的，但通常是双向的



##### 间接通信

* 定向从消息队列接收消息

  > 对消息接收方，不需要关注消息是从哪来的
  >
  > 对消息发送方，不需要关注具体是谁收到了消息，只要发送给队列就可以了
  >
  > 中间节点一般是内核中共享的资源

  * 每个消息队列都有一个唯一的ID
  * 只有它们共享了一个进程队列，进程才能够通信

* 通信链路的属性：

  * 只有进程共享一个共同的消息队列，才建立链路
  * 链接可以与许多进程相关联
  * 每对进程可以共享多个通信链路
  * 链接可以是单向或者双向

* 操作：

  * 创建一个新的消息队列

  * 通过消息队列发送和接收消息

    * `send(A, message)`：发送消息到队列A
    * `receive(A, message)`：从队列A接收消息

  * 销毁消息队列

    > 缓存空间已经没用了，需要回收资源



##### 通信阻塞与非阻塞

* 消息传递可以是阻塞和非阻塞的
* 阻塞认为是同步的：
  * `Blocking send`：消息发送方阻塞，直到消息被接受
  * `Blocking receive`：消息接收方在调用`receive`方法后阻塞，直到消息到达可用
* 非阻塞认为是异步的：
  * `Non-blocking send`：消息发送方发送完消息就立刻继续执行
  * `Non-blocking receive`：消息接收方在调用`receive`方法后要么得到一个有效的结果，要么得到一个空值，即不会被阻塞



##### 通信链路缓冲

* 队列的消息被附加到链路中，存在消息缓冲区来解决发送方接收方速度可能不一致的问题

* 消息缓冲区有三种情况：

  1. 0容量：`0 message`

     * 发送方必须要等待接收方，也即阻塞模式

  2. 有限容量：`n messages`的有限长度

     * 如果队列满了，则发送方必须等待接收方

  3. 无限容量

     > 分析模拟时的情况，理想情况

     * 发送方不需要等待

     > 个人理解：这里和非阻塞不一样，如果缓冲区没有信息时，进程调用`receive`可能需要等待，如果是阻塞模式的话



___

### 信号

* `Signal`

  * 软件中断，通知事件处理

    > 《2.2 操作系统中断/异常/系统调用》：中断分为硬件中断和软件中断
    
  * 例如：`SIGFPE`，`SIGKILL`杀死信号，`SIGSTOP`暂停信号，`SIGCONT`
  
* 接收到信号后会发生的几种情况：

  1. 缺省情况下，依靠操作系统的默认操作

     > Linux对每种信号都规定了默认操作

  2. `Ignore`：忽略信号，不处理

     > 但是有两个信号不能忽略：即`SIGKILL`及`SIGSTOP`

  3. `Catch`：捕获信号，定义信号处理函数，接收到信息时调用相应的处理函数

     > 编写应用程序时，如果需要关注某个信号，则编写相应的处理函数，指定哪个信号产生哪个响应

     > 一般情况下，根据操作系统大致的约定，处理完之后会回到被打断的程序，重新执行

* 信号的特点：

  * 缺点：不能传输要交换的任何数据

    > 传输很小的一个bit，起到通知的作用

  * 优点：效率很高，类似于异步打断的机制

* 信号的实现：

  > 操作系统如何帮助实现该功能？
  >
  > ![信号的实现](.\pics\11-7.png)

  1. 应用程序想要对某个信号做特定处理的话，需要先注册一个针对该类信号的`handler`，发送给操作系统，当操作系统收到该信息后就知道如果收到该信号，要调用应用程序专门编写的信号处理函数来执行

  2. 产生了信号后，如何中断正在运行的程序，并跳到信号处理函数上运行？

     > 当操作系统看到该类信号时，运行在内核态；从内核态返回到用户态去执行响应信号程序的时候，返回到调用信号处理函数的入口（系统调用返回的用户空间的堆栈进行修改，本来应该返回到系统调用语句的后一条语句去执行，变成了到信号处理函数的入口），同时，再把信号处理函数之后要执行的地址作为后一个栈帧的返回地址（即将中断位置放到了下一个栈指针的返回位置）。
     >
     > 在其他情况下，编写程序不会修改应用程序的堆栈，但木马病毒往往会这么做。
     >
     > 参见《2.2 操作系统中断/异常/系统调用》



___

### 管道

* `Pipe`：很早的Linux进程间通信机制，将一个程序的输出定向为另一个程序的输入

* 父进程为子进程创建，子进程从父进程继承文件描述符
* 管道其实是内核中的一块Buffer，管道兼具读端/写端
* 通过Buffer将进程的输入输出通过重定向连接起来，而连接的两个进程本身并不知道（或不关心）输出或输入自哪里

* 以`% ls | more`命令为例：

  > ![ls|more命令](.\pics\11-8.png)

  * shell建立好管道
  * 为`ls`创建一个进程，设置`stdout`为管道写端
  * `more`创建一个进程，设置`stdin`为管道读端
  * `ls`与`more`有统一的父进程`shell`

* 管道的buffer是有限的，如果buffer已经满了，则会阻塞

  > [通信链路缓冲](#通信链路缓冲)中的有限容量情形

* 缺点：
  * 它是半双工的，即一个管道上的数据只能在一个方向上流动，如果要实现双向通信，就必须在两个进程之间建立两个管道
  * 管道只能在具有公共祖先的两个进程之间使用
  * 管道中的数据是字节流，没有一种结构化的表现形式



____

### 消息队列

- 有buffer size的限制，因此同样会阻塞
- 按照FIFO来管理信息
- 不需要父进程创建
- 传递结构化的数据



____

### 共享内存

* 管道和消息队列都是间接通信，而共享内存是直接通信
* 进程间明确地设置了共享内存段，进程的虚拟地址映射到同一个物理地址
* 优点：不需要经过系统调用，所以可以方便高效地共享数据
  * 最快的方法
  * 一个进程写，另一个进程就立即可见
  * 没有系统调用干预
  * 没有数据复制
* 缺点：必须同步数据访问，需要同步互斥的机制保证确定性
  * 不提供同步，需要由程序员提供同步