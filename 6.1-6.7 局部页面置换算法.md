# 6.1-6.7 局部页面置换算法

[TOC]

### 页面置换算法

* 局部页面置换算法：
  * 最优页面置换算法（OPT，optimal）
  * 先进先出算法（FIFO）
  * 最近最久未使用算法（LRU，Least Recently Used）
  * 时钟页面置换算法（Clock）
  * 最不常用算法（LFU，Least Frequently Used）
  * Belady现象
  * LRU、FIFO和Clock的比较
* 全局页面置换算法：
  * 工作集模型
  * 工作集页置换算法
  * 缺页率置换算法

* 功能：当缺页中断发生，需要调入新的页面而内存已满时，**选择内存中哪个物理页面（帧）被置换**

* 目标：尽可能地减少页面的换进换出次数，即减少缺页中断的次数

  > 具体说，把未来不再使用或短期内较少使用的页面换出，通常只能在**局部性原理**指导下依据过去的统计数据来进行预测
  >
  > 局部性原理参考《5.4&5.5-虚拟内存管理技术》中的**程序局部性原理**

* **页面锁定（frame locking）**：用于描述必须常驻内存的操作系统的关键部分或者时间关键（time-critical）的应用进程
  
* 实现的方法是在页表中添加**锁定标志位（lock bit）**
  
* **为了分析比较不同的页面置换算法，设置一定的实验环境：**

  1. 记录一个进程对页访问的一个轨迹：

     * （虚拟）地址跟踪（页号，位移）

       ```ascii
       (3,0), (1,9), (4,1), (2,1), (5,3), (2,0), (1,9), (2,4) 
       ```

     * 生成页面轨迹，即访问序列

       > 不需要考虑offset位移，只关注页号

       ```ascii
       3, 1, 4, 2, 5, 2, 1, 9 
       ```

  2. 模拟一个页面置换的行为并记录产生页缺失数的数量

     * 页面置换算法产生的缺失越少，则性能越好



### 最优页面置换算法

* 基本思路：当一个缺页中断发生时，对于保存在内存中的每一个逻辑页面，计算在它的下一次访问前，还需要等待多长时间，将等待时间最长的那个，作为被置换的页面

* 这只是一种理想情况，在实际系统中是**无法实现**的

  > 因为操作系统无从知道每一个页面要等待多长时间才会被再次访问

* 可用作其他算法的性能**评价的依据**

  > 在一个模拟器上运行某个程序，并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法

* 因此如果一个页面置换算法的缺页情况能够尽量逼近最优算法，就认为该算法比较好

* 实例：

  >![最优页面置换算法](.\pics\zuiyou.png)



### 先进先出算法

* **First-In First-Out**：`FIFO`
* 基本思路：选择内存中驻留时间最长的页面置换出去
  * 系统维护一个链表，记录所有位于内存中的逻辑页面
  * 从链表的排列顺序看，链表表头的页面驻留时间最长，链尾页面驻留时间最短
  * 当发生缺页中断时，将链首页面换出，并把新的页面换入放到链表末尾

* 缺点：性能较差，调出的页面有可能是经常要访问的页面，并且有[Belady现象](#Belady现象)

  > 所以FIFO算法很少单独使用

* 实例：

  > ![FIFO](.\pics\FIFO.png)



### 最近最久未使用算法

* **Least Recently Used**：`LRU`

* 基本思路：当一个缺页中断发生时，选择最久未使用的那个页面置换出去

  * 是对**最优页面置换算法**的一个近似

  * **依据**：程序的局部性原理

    > 程序的局部性原理参考《**5.4&5.5-虚存技术.md**》

    * 在最近一小段时间或最近几条指令内，如果某些页面被频繁访问，那么在将来的一小段时间内，它们还可能会再一次被频繁访问
    * 相应的，如果过去某些页面长时间未被访问，那么将来它们还可能长时间地得不到访问

* 实例：

  > ![LRU](.\pics\LRU.png)

##### LRU的实现方法

* LRU算法要记录各个页面使用时间的先后，**开销较大**

* 两种可能的实现方式：

  > 个人感觉思路完全一样，只是实现方式使用的数据结构不同

  1. 链表：
     * 系统维护一个页面链表，最近刚刚使用的页面作为首结点，最久未使用的页面作为尾结点
     * 每一次访问内存时，找到相应的页面，把它从链表中摘下来，再移动到链表之首
     * 每次缺页中断发生时，淘汰链表末尾的页面
  2. 栈：
     * 设置一个活动页面栈，当访问某页时，将此页号压入栈顶
     * 然后考察栈内是否有与此页面相同的页号，若有则抽出
     * 每次缺页中断发生时，淘汰栈底的页面

* 实例：

  >![栈实现的LRU](.\pics\LRU2.png)

* 注意：

  * 每次内存访问，都需要进行一次查找，看该页面是否在链表或者堆栈中，因此开销太大

    > 尤其是当页很多，链表或者堆栈很长时，开销更大

  * **虽然LRU的效果比较好，但是开销太大，所以不是有效的算法**





### 时钟页面置换算法

* Clock页面置换算法：是对LRU的近似，对FIFO的一种改进

  > 相比于LRU，使用一个bit的`access bit`，只用访问位近似表示最近访问的情况，开销比LRU算法小得多
  >
  > 详见[FIFO、LRU和Clock的比较](#FIFO、LRU和Clock的比较)

  <img src=".\pics\clock1.png" alt="clock页面置换算法示意图" style="zoom:75%;" />

* 基本思路：

  * 需要使用页表项中的**访问位（access bit）**：当一个页面被装入内存中时，把该位**初始化为`0`**，在这之后如果这个页被访问（读/写），则将访问位**置**为`1`

    > 个人想法：从下文的实例中可以看出，虽然初始化为0了，但是因为是CPU需要读取了才会主动置换加载到内存中，所以访问位又被置`1`了

    > **访问位**参考《**5.4&5.5 虚拟内存管理技术**》中的**页表表项**

    > 这个置为`1`的过程由硬件完成，不需要软件参与，但是软件也可以做清`0`操作和置`1`操作

  * 将各个页面组织为环形链表，指针指向最老的页面（最先进来）

    > 类似于钟的表面

    > **LRU中指向的是最久未使用，而Clock中指向的是最先进来的**

  * 当发生一个缺页中断时，考察指针指向的最老页面：

    * 如果它的访问位为`0`：将其置换出去，指针移动到下一格，结束
    * 如果它的访问位为`1`：
      * 则把该位（access bit）置`0`，然后指针移动到下一格
      * 继续依此判断，直到找到被淘汰的页面，把指针移动到下一格，结束

* 实例：

  > ![clock实例](.\pics\clock2.png)
  >
  > 注意：在第四步时，所有的access bit都变成`1`了，又在第五步时清`0`



### 二次机会法

* 二次机会法：也叫**Enhanced Clock algorithm**

  <img src=".\pics\enhancedclock.png" alt="二次机会法" style="zoom:75%;" />

  * 由于替换**脏页（dirty page）**的代价比未修改过的页要大很多，所以要尽量避免置换**进行过写操作的页**

    > 参见《**5.4&5.5 虚拟内存管理技术**》中的**修改位**
    >
    > `dirty page`：脏页在页表表项中的**修改位**为`1`，说明该页在内存中被修改过，释放内存前需要先将内容写入硬盘中

  * **是对Clock算法的修改**，使它允许脏页总是在一次时针头扫描中保留下来

* 基本思路：**同时使用脏位和使用位来指导置换**

  > 脏位：修改位
  >
  > 使用位：访问位access bit

  * 所有访问页组织为环形列表，指针指向最老的页面（最先进来）

  * 当发生一个缺页中断时，考察指针指向的最老页面：

    * 如果它的访问位为`0`并且脏位为`0`：将其置换出去，指针移动到下一格并且结束
    * 如果它的访问位为`0`但是脏位为`1`：将其脏位清为`0`，指针移动到下一格
    * 如果它的访问位为`1`但是脏位为`0`：将其访问位清为`0`，指针移动到下一格
    * 如果它的访问位为`1`并且脏位为`1`：将其访问位清为`0`，脏位保持不变，指针移动到下一格

    > 如果一个页访问位或者脏位都是`1`，指针需要两次通过它，才能将其都置为`0`，这使得只读的页会更加容易被换出，从而减少了硬盘的访问次数。

* 实例：

  >![二次机会法实例](.\pics\enhancedclock2.png)

* 由于二次机会法相较于Clock算法，更好地体现了对`读`和`写`的区别对待，减少了磁盘的读写次数，所以比Clock算法更好



### 最不常用算法

* **Least Frequently Used**：`LFU`

* 基本思路：当一个缺页中断发生时，选择访问次数最少的那个页面，将其置换出
  * 对每个页面设置一个访问计数器，每当一个页面被访问一次，该页面的访问计数器加1
  * 当发生缺页中断时，将计数值最小的页面置换出
* 缺点：
  * 硬件成本高：如果为每个页面增加一个寄存器实现访问计数器，开销很大
  * 效率低：每次页面置换需要遍历所有页的计数值，时间开销很大

##### LFU与LRU的区别

* LRU考察的是多久未访问，时间越短的越要留在内存中

* LFU考察的是访问的次数即频度，访问次数越多的越要留在内存中

  > LFU的反例：一个页面在进程开始时使用很多，但以后就不使用了，但LFU会一直把它放在内存中
  >
  > 解决方法：定期把次数寄存器右移一位（二进制中相当于除以2）



### Belady现象

* belady现象：在采用FIFO算法时，有时会出现分配的物理页面数增加，缺页率反而升高的异常现象

  > 一般情况下，给一个程序分配的物理页面越多，缺页率应该下降

* **belady现象的原因**：FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标（替换较少使用的页面）是不一致的，因此被它置换出去的页面并不一定是进程不会访问的

  > FIFO：先进先出，first-in first-out

* 实例：

  ```ascii
  访问顺序：123412512345
  FrameSize：3
  PageFault：9
  ```
  
| FIFO         | 1    | 2    | 3    | 4    | 1    | 2    | 5    | 1    | 2    | 3    | 4    | 5    |
  | ------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | Tail         | 1    | 2    | 3    | 4    | 1    | 2    | 5    | 5    | 5    | 3    | 4    | 4    |
  |              |      | 1    | 2    | 3    | 4    | 1    | 2    | 2    | 2    | 5    | 3    | 3    |
  | Head         |      |      | 1    | 2    | 3    | 4    | 1    | 1    | 1    | 2    | 5    | 5    |
  | Page Default | X    | X    | X    | X    | X    | X    | X    |      |      | X    | X    |      |
  
> 将物理页帧从3上调到4
  
  ```ascii
  访问顺序：123412512345
  FrameSize：4
  PageFault：10
  ```
  
  | FIFO         | 1    | 2    | 3    | 4    | 1    | 2    | 5    | 1    | 2    | 3    | 4    | 5    |
  | ------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | Tail         | 1    | 2    | 3    | 4    | 4    | 4    | 5    | 1    | 2    | 3    | 4    | 5    |
  |              |      | 1    | 2    | 3    | 3    | 3    | 4    | 5    | 1    | 2    | 3    | 4    |
  |              |      |      | 1    | 2    | 2    | 2    | 3    | 4    | 5    | 1    | 2    | 3    |
  | Head         |      |      |      | 1    | 1    | 1    | 2    | 3    | 4    | 5    | 1    | 2    |
  | Page Default | X    | X    | X    | X    |      |      | X    | X    | X    | X    | X    | X    |

* **LRU算法不会产生Belady现象，为什么？**

  > 超出了本堂课内容，老师建议自己课后查找

  * LRU算法符合栈算法的特点



### FIFO、LRU和Clock的比较

* FIFO和LRU本质上都是先进先出的思路，但是：

  * FIFO针对页面进入内存的时间排序，各个页面的排序是固定不变的，进入最早的会先被置换

  * LRU针对页面最近访问的时间排序，会根据进程的访问来动态调整顺序，最久未访问的会先被置换

    > LRU需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序，因为有一个页面的最近访问时间变了

  * 因此如果一个页面进入内存后没有被访问，那么它的最近访问时间就是它进入内存的时间，LRU算法就退化为FIFO算法

    > 如果程序不具有局部性时，LRU的表现可能跟FIFO算法一样

    > 比如分配给一个进程3个物理页面，逻辑页面的访问顺序为1，2，3，4，5，6，1，2，3……

* Clock算法是对LRU算法的近似：只用访问位近似表示最近访问的情况，开销比LRU算法小得多

* 程序的局部性会影响Clock和LRU的表现：

  * 当程序具有良好局部性时，Clock算法和LRU算法表现较好
  * 当程序不具有局部性时，Clock算法和LRU算法就退化为FIFO算法

* 在系统开销上：

  * FIFO算法系统开销小，但是可能会发生Belady现象

  * LRU算法性能好，但是系统开销大

  * Clock算法是折衷的办法

    1. 在系统开销方面：在每一次页面访问时，不必动态地调整该页面在链表中的顺序，而仅仅是做一个标记，然后等到发生缺页中断时，再把它移动到链表末尾

    2. 在算法性能上：
       * 对于内存中那些未被访问的页面，Clock算法的表现和LRU算法一样好
       * 对于曾经被访问的页面，Clock算法不能像LRU算法那样记住它们的准确位置