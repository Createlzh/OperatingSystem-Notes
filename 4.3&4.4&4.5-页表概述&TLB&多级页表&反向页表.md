# 4.3-4.5 页表概述&TLB&多级页表&反向页表

[TOC]

____

### 页表概述

##### 页表项

* 每个运行的程序都有一个页表

  * 属于程序运行状态，会动态变化
  * `PTBR`：页表基址寄存器

* **页表项的内容**：

  ![页表结构](.\pics\page3.png)
  1. **标志位**`Flags`：

     * dirty bit

     * resident bit

       > 表示页表项是否合法，因为部分逻辑页没有对应的物理帧

     * clock/reference bit

  2. 帧号`frame number`

* 地址转换的实例：

  >  ![地址转换实例](.\pics\page4.png)
  >
  > ```ascii
  > 1 0 0 | 0 0 0 0 0 表示物理地址不存在
  > 0 1 1 | 0 0 1 0 0 表示物理地址存在，帧号为4
  > ```
  >
  > 页表前三位是`Flags`，第二位的`resident bit`为0时，说明该逻辑地址没有对应的物理帧，会出现内存访问异常：一般情况下，认为是非法访问时会将该程序杀死。

  

##### 分页机制的性能问题

1. 空间：页表可能非常大，无法放入CPU中而放在内存中

   > 64位机器如果每页1024字节，那么一个页表大小？`2^64 / 2^10 = 2^54`

2. 时间：由于页表存放在内存中而不是CPU中，访问一个内存单元需要两次内存访问

   > 一次用于获取页表项，一次用于访问数据

* 如何解决？
  1. 缓存（Caching）
  2. 间接（Indirection）访问：多级页表机制



### TLB

* **TLB解决了分页机制性能的时间问题**

* **TLB**（Translation Look-aside Buffer）：**缓存(Cache)近期访问的页帧转换表项**

  ![TLB](.\pics\page5.png)

  > **CPU中**的快表TLB，为`(key, value)`的形式，`key`为页号，`value`为帧号

  > 注意TLB本身不是存储设备，而是一种数据结构

  * TLB使用associative memory（关联内存）实现，具备快速访问性能

  * 如果TLB命中，物理页号可以很快备货区

  * 如果TLB未命中，对应的表项被更新到TLB中

    > CPU内存有限，如果TLB中没有需要的，就只能去查找**内存中**的页表

    > 将TLB中没有的表项从页表中更新到TLB：
    >
    > * 在部分CPU中，由CPU硬件完成
    > * 在部分CPU中，由操作系统完成

* 为了让TLB缺失尽可能少，编写程序尽量使程序具有访问局部性，让访问集中在一个区域



### 二级&多级页表

* **多级页表会使得每次访问的开销变大，因为需要多次查页表**
* **使用时间换取空间**

##### 二级页表

* 把单一的页表分成了两部分：`一级页表`与`二级页表`

* 相应的，逻辑地址`(p, o)`中的`o`没变，但`page number`分成了两部分：对应一级页表的页号`p1`与二级页表的页号`p2`

  > 使得寻址不是在一个大的页表`page table`，而是在n个小的`page table`

  ![二级页表](.\pics\page6.png)

* 一级页表中页表项存储的是二级页表的起始地址

  > 通过这种方式，不存在对应物理地址的次级页表就不需要存放在内存中了

  > 而在之前的页表方案中，即使`resident number`为0，对应的空间还需要保留

* 二级页表中存储的是帧号`f`即`frame number`



##### 多级页表

* 通过把页号分为`k`个部分，实现多级间接页表

* 建立页表树：

  ![多级页表](.\pics\page7.png)



### 反向页表

> 是否有一种方法，使得页表的大小与逻辑空间的大小没有关系？

* 大地址空间问题：

  * 大地址空间（64-bits），前向映射页变得繁琐

    > 比如5级页表

  * 不是让页表与逻辑空间的大小相对应，而是让页表与物理地址空间的大小相对应

    > 逻辑（虚拟）地址空间增长速度快于物理地址空间



##### 基于页寄存器的方案

* 页寄存器：Page Registers

  ![基于页寄存器的方案](.\pics\page8.png)

  

  >  index索引不是页号而是帧号，而数组项为页号等信息
  >
  > 大小与物理地址空间的大小相关

* 每个帧和一个寄存器相关联，寄存器的内容包括：

  * Residence bit：此帧是否被占用
  * Occupier：对应的页号`p`
  * Protection bits：保护位

* 页寄存器的一个实例：

  > 物理内存大小：4096\*4096=4K\*4KB=16MB
  >
  > 页面大小：4096bytes=4KB
  >
  > 页帧数：4096=4K
  >
  > 页寄存器占用的空间？（假设8 bytes/register）
  >
  > > 8*4096=32 Kbytes
  >
  > 页寄存器带来的额外开销？
  >
  > > 32K/16M=0.2%
  >
  > 虚拟（逻辑）内存的大小：任意

* 页寄存器方案的权衡：

  * **优点**：所占空间很小
    - 转换表的大小相对于物理内存来说很小
    - 转换表的大小跟逻辑地址空间的大小无关
  * **缺点**：
    * 需要的信息对调了，变为由帧号找页号
    * 如何转换回来比较麻烦，需要在反向页表中搜索想要的页号



##### 基于关联内存的方案

![基于关联内存的方案](.\pics\page9.png)

* 如果帧数较少，页寄存器可以放置在关联内存中
* 在关联内存中查找逻辑页号：
  * 成功：帧号被提取
  * 失败：页错误异常（page fault）
* 限制因素：成本很高，大量的关联内存非常昂贵
  * 难以在单个时钟周期内完成
  * 耗电



##### 基于哈希查找的方案

> 日后整理，参见[教程](https://www.bilibili.com/video/BV1js411b7vg?p=19)