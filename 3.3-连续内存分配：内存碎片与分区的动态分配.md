# 3.3 连续内存分配：内存碎片与分区的动态分配

[TOC]

### 内存碎片问题

* **内存碎片**：空闲内存不能被利用

  * **外碎片**：在分配单元之间的未使用内存

  * **内碎片**：分配单元中的未使用的内存

    > 即已经分配给了应用程序，但是应用程序无法进一步使用



### 分区的动态分配

* 简单的内存管理方法：
  * 当一个程序准许运行在内存中时，分配一个连续的内存空间
  * 当运行的程序需要访问数据，分配一个连续的内存空间



##### 第一适配

* **定义**：为了分配n字节，从0地址顺序查找，找到第一个比n大的可用空闲块

* **需求**：

  * 按地址排序的空闲块列表

  * 分配需要寻找一个合适的分区

  * 重分配需要检查，看自由分区是否能合并于相邻的空闲分区（如果有的话）

    > 回收的时候，需要考虑能否和相邻的空块合并

* **优点**：

  1. 简单

  2. 易于产生更大的空闲块（向着地址空间的结尾处）

     > 因为不太会把后面的大空闲块分散成小块

* **缺点**：

  1. 容易产生外部碎片

     >第一个大块被使用后可能留了一个小块，在下一次需要大块时这个小块就不太可能用上了

  2. 不确定性



##### 最优适配

* **定义**：为了分配n字节，使用最小的比n大的可用空闲块

* **需求**：
  * 按尺寸排序的空闲块列表
  * 分配需要寻找一个合适的分区
  * 重分配需要检查，看自由分区是否能合并于相邻的空闲分区（如果有的话）

* **优点**：
  1. 比较简单
  2. 当大部分分配是小尺寸时非常有效

* **缺点**：

  1. 重分配慢

  2. 容易产生外部碎片

  3. 易产生很多没用的碎小碎片

     > 把块拆得很小，碎片也越来越小越来越多



##### 最差匹配分配

* **定义**：为了分配n字节，使用最大的比n大的可用空闲块

* **需求**：
  * 按尺寸排序的空闲块列表
  * 分配很快（获得最大的分区）
  * 重分配需要检查，看自由分区是否能合并于相邻的空闲分区（如果有的话），然后调整空闲块列表

* **优点**：
  1. 假如分配是中等尺寸效果最好

* **缺点**：
  1. 重分配慢
  2. 外部碎片
  3. 易于破碎大的空间块以致于大分区无法被分配





