# 7.8-7.11 线程

[TOC]

### 为什么要线程

> 以编写一个MP3播放软件为例
>
> 软件的核心功能有三个：
>
> 	1. 从MP3音频文件中读取数据
>  	2. 对数据进行解压缩
>  	3. 把解压缩之后的音频数据播放出来
>
> ```c++
> //单进程的实现方法
> main()
> {
>     while(TRUE)
>     {
>         Read(); // I/O
>     	Decompress(); // CPU
>         Play();
>     }    
> }
> Read(){..};
> Decompress(){..};
> Play(){..};
> 
> /*问题:播放出来的声音是否连贯？
> 各个函数之间不是并发执行，影响资源的使用效率
> CPU等待I/O完成之后才能解压，而硬盘速度又慢，形成了瓶颈
> */
> ```
>
> ```c++
> //多进程的实现方法
> //程序1
> main()
> {
>     while(TRUE)
>     {
>         Read();
>     }
> }
> Read(){..};
> 
> //程序2
> main()
> {
>     while(TRUE)
>     {
>         Decompress();
>     }
> }
> Decompress(){..};
> 
> //程序3
> main()
> {
>     while(TRUE)
>     {
>         Play();
>     }
> }
> Play(){..};
> ```

* 进程的问题：
  * 进程不能互相访问地址空间；进程之间的通信与共享数据需要操作系统来完成，开销较大
  * 创建进程时，分配资源，建立PCB；撤销进程时，回收资源，撤销PCB
  * 进程切换时，要保存当前进程的状态信息
  * 所以并发的开销会比较大
* 需要一种新的实体：线程
  * 实体之间可以并发地执行
  * 实体之间共享相同的地址空间



### 线程

* 线程是进程当中的一条执行流程

* 重新理解进程：分为**资源管理**和**线程**两部分

  1. 从资源管理的角度看：进程把一组相关的资源组合起来，构成了一个资源平台（环境）

     > 包括地址空间（代码段、数据段）、打开的文件、访问的网络等各种资源

  2. 从运行的角度看：代码在这个资源平台上的一条执行流程（线程）

     > 同一个进程下的不同线程，共享进程的代码段、数据段、内存、文件等资源

* 线程控制块：`TCB`

  > 进程控制块：`PCB`

  * TCB只负责管理执行流程相关的信息
  * TCB包括程序计数器，状态，堆栈，寄存器信息，每个进程各自独立

* 线程的优点：
  - 一个进程中可以同时存在多个线程
  - 各个线程可以并发地执行
  - 各个线程之间可以共享地址空间、文件等资源
* 线程的缺点：
  * 一个线程崩溃，会导致其所属进程中的所有线程崩溃，整个进程也就死亡了
  * 线程的安全可靠性没有保障

* 线程与进程的选择：

  * 追求高性能计算，且执行流程比较类似时，一般使用线程

    > 如天气预报的计算

  * 追求安全性而性能不是瓶颈时，使用进程

    > 如浏览器就是用多进程实现的

* 线程需要的资源：

  * 单线程：进程中只有一个控制流，所有资源都是它的

  * 多线程：多个控制流

    * 共享：代码段，数据段，文件资源，网络资源等
    * 独占：与控制执行相关，计数器，寄存器，堆栈等

    ```ascii
    ------------------------------         -----------------------------------
      code       data      files               code       data      files
    ------------------------------         -----------------------------------
       resigsters      stack               | r1 s1    |   r2 s2  |  r3  s3   |
    ------------------------------         -----------------------------------
                                           |          |          |          |
                    /                      |   /      |   /      |   /      |
          thread -> \                      |   \ t1   |   \  t2  |   \  t3  |
                    /                      |   /      |   /      |   /      |
                    \                      |          |          |          |
    ------------------------------         ----------------------------------- 
    
            single-threaded                          multi-threaded
    ```

    

### 线程与进程的比较

* 进程是资源分配的单位，线程是CPU调度的单位

* 进程是一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈

* 线程同样具有`就绪`、`阻塞`、`执行`三种基本状态，同样具有状态之间的转换关系

* 线程可以减少并发执行的空间和时间开销：

  - 线程的创建时间比进程短

    > * 因为进程创建过程中要创建内存管理信息，文件管理信息
    >
    > * 线程创建时则可以直接使用进程管理好的资源

  - 线程的终止时间比进程短

    > 同理，因为不需要线程进程资源的释放

  - 同一进程内的线程切换时间比进程短

    > * 因为同一个进程的线程共用地址空间，页表同用，不涉及页表的转换
    >
    > * 而进程之间的切换，需要切换页表（开销大），会使缓存，硬件的信息无效，需要重新加载

  - 同一进程的线程共享内存和文件资源，可以直接进行不通过内核的通信



### 线程的实现

* 主要有三种线程的实现方式：

  1. 用户线程：在用户空间实现

     > user thread，操作系统看不到的线程，应用态的应用程序的库来管理
     >
     > 操作系统可以看到进程的信息，但看不到线程的信息

  2. 内核线程：在内核中实现

     > kernel thread，操作系统能够看到，操作系统管理起来的线程

  3. 轻量级线程：在内核中实现，支持用户线程

* 用户线程与内核线程的对应关系

  1. 多对一

     > 多个用户线程对应一个内核线程

  2. 一对一

  3. 多对多



##### 用户线程

* 用户线程示意图：

  > ![用户线程](.\pics\thread1.png)
  >
  > **TCB放在用户空间，对操作系统不可见**

* **用户线程**：在用户空间实现的线程机制，不依赖于操作系统的内核，由一组**用户级的线程库函数**来完成线程管理

  > 包括包括线程的创建，终止，同步和调度等

  * 由于用户线程的维护由相应进程完成（通过线程库函数），不需要操作系统内核了解用户线程的存在，可用于不支持线程技术的多进程操作系统

    > 操作系统只能看到进程信息，进程中的线程信息操作系统无法知道

  * 每个进程都需要它自己私有的线程控制块`TCB`列表，用来跟踪记录它的各个线程的状态信息（PC，栈指针，寄存器），TCB由线程库函数维护
  * 用户线程的切换由线程库函数来完成，无需进行用户态/内核态的切换，速度非常快
  * 由于不属于内核管理，每个进程可以自定义自己的线程调度算法

* 用户线程的缺点：

  * 如果一个用户线程发起系统调用而阻塞，则整个进程在等待，可能会被挂起

    > 因为OS只能感知到进程，一个线程发出阻塞性调用，OS会把整个进程阻塞，其余线程也就等待了

  * 一个线程开始后，除非该线程主动让出CPU，否则它所在的进程当中的其它线程将无法运行

    > 用户态的线程库无法主动中断当前用户线程的执行，而操作系统有，OS可以管理中断，特别是时钟中断

  * 由于时间片分配给进程，多线程执行时，每个线程得到的时间片更少了，运行较慢



##### 内核线程

* 内核线程示意图：

  > ![内核线程示意图](.\pics\thread2.png)
  >
  > **TCB也放在内核空间，对操作系统可见**

* **内核线程**：是指操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建，管理和终止

  > 进程主要完成资源的管理，PCB管理一系列TCB，但具体的调度是由TCB完成的

  * 在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息（PCB和TCB）
  * 线程的创建，终止和切换都是通过系统调用/内核函数的方式进行，由内核完成，系统开销较大
  * 每次线程的切换都会有内核态/用户态的切换，开销较大
  * 操作系统调度单位为线程，在一个进程中，如果某个内核线程发起系统调用而被阻塞，并不会影响其它内核线程运行
  * 时间片分配给线程，多线程的进程获得更多的CPU时间



##### 轻量级进程

* Light Weight Process：是内核支持的用户线程

  * 一个进程可有一个或者多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持

    > `Solaris`/`Linux`



### 上下文切换

* 定义：停止当前运行进程（从运行状态改变成其他状态）并且调度其他进程（转变成运行状态）

  * 必须在切换之前存储许多部分的进程上下文

    * 寄存器（计数器，栈指针，…），CPU状态，…

      > 程序计数器：进程执行到什么地方
      >
      > 栈指针：调用关系，局部变量的位置

    * 有些时候可能比较费时，所以应该尽可能避免

  * 停止一个进程时，要将其上下文信息存放到它的PCB中

  * 让另外一个进程运行时，需要将其PCB中的上下文信息取出，放入CPU中，恢复它上一次停止时的状态

  * 必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过

  * 必须快速高效（上下文转换是非常频繁的）

    > 使用汇编实现

* 示意图

  > ![上下文切换](.\pics\thread3.png)

* 操作系统为活跃进程准备了PCB：

  * 操作系统将PCB放在合适的队列中

    * 就绪队列

    * 等待I/O队列（每个设备的队列）

    * 僵尸队列

      > 后续讲解