# 6.8 局部页面置换方法的问题&工作集

[TOC]

### 局部页面置换算法的问题

> 例：`FIFO`算法的`Belady`现象

* 各种局部页面替换算法有效都是基于一个前提：**程序的局部性原理**

  * 如果局部性原理不成立：那么各种页面置换算法也就没有什么分别，也没有什么意义

    > 例如假设进程对逻辑页面的访问顺序是1、2、3、4、5、6、7...，即单调递增，那么在物理页面数有限的前提下，不管采用何种置换算法，每次的页面访问都必然导致缺页中断

  * 如果局部性原理市成立的：那么如何证明它的存在，如何对它进行定量分析？

    > 这就是工作集模型！



### 工作集

* **工作集**：一个进程当前正在使用的逻辑页面的**集合**，可以用一个二元函数`w(t, △)`来表示

  > 集合不含重复元素，见下方实例

  * `t`表示当前的执行时刻

  * `△`称为**工作集窗口**(working-set window)，即一个定长的页面访问的时间窗口

    > 就是时间间隔

  * `w(t, △)`就是当前时刻`t`之前的`△`时间窗口当中的所有页面所组成的集合

    > 是过去一段时间`(t-△,t]`逻辑页面的集合，随着`t`的推进，这个集合也在不断变化

  * `|w(t, △)|`为工作集的大小，也就是区间`(t-△,t]`这个范围内逻辑页面的数量

    * 在某一`(t-△,t]`上，`|w(t, △)|`较小说明该程序在那一范围内，局部性较好

  > ```ascii
  > 页面访问顺序如下：
  > 92615777751 62341234443434441327
  >  ▲        ▲        ▲        ▲          
  >  │--△=10--│       |--△=10--│
  >  t=2      t1=11             t2
  > 如果△时间窗口的长度为10，那么：
  > w(t1, △) = {1, 2, 5, 6, 7,}
  > w(t2, △) = {3, 4}
  > ```
  >
  > 这个例子中，`t2`的局部性比较强，`t1`具有一定的局部性但是不如`t2`

* 工作集大小的变化:
  * 进程开始执行后，随着访问新页面逐步建立较稳定的工作集
  * 当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定
  * 局部性区域位置改变时，工作集快速扩张和收缩过渡到下一个稳定值



### 常驻集

* **常驻集**：指的是当前时刻，进程**实际驻留**在内存中的页面的集合

* 工作集是进程在运行过程中的固有的性质，而常驻集却决于系统分配给进程的物理页面数目，以及所采用的页面置换算法

* 如果一个进程的整个工作集都在内存中，即常驻集`包含`或`等于`工作集，那么进程将很顺利地进行，而不会造成太多的缺页中断，直到工作集发生剧烈变动，从而过渡到另一个状态

* 进程常驻集的大小达到某个数量之后，再给它分配更多的物理页面，缺页率也不会显著降低

  > 所以动态调整常驻集的大小（也就是分配给单个进程的物理页面的数量），把多余的分配给其它进程，使得整体的缺页次数降低

