# 9.1-9.8 同步

[TOC]

___

### 背景

> 到目前为止：
>
> * 多道程序设计（multi-programming）：现代操作系统的重要特性
> * 并行很有用：多个并发实体，CPU(s)，I/O，用户，...
> * 进程/线程：操作系统抽象出来，用于支持多道程序设计
> * CPU调度：实现多道程序设计的机制
> * 调度算法：不同的CPU调度策略
>
> 不同的进程可能涉及到很多交互，处理不当可能会导致饥饿、死锁等问题



##### 独立线程与合作线程

* 独立的线程：

  > 不占用相同的资源，或没有相互的交互

  * 不和其它线程共享资源或状态
  * 确定性：输入状态决定结果
  * 可重复性：能够重现起始条件，I/O
  * 调度顺序不重要

* 合作线程：

  > 需要共同访问资源，或者进行交互

  * 在多个线程中共享状态
  * 不确定性
  * 不可重现

  > 调度顺序可能受很多因素影响，进程执行的时间也就不确定，执行过程中的资源可能会被抢占，因此执行的结果可能也不同，因此有不确定性和不可重现
>
  > > 见下方的[不确定性问题](#不确定性问题)和[原子操作](#原子操作)

  * 不确定性和不可重现意味着bug可能是间歇性发生的



##### 为什么线程要合作

> 进程/线程，计算机/设备需要合作

1. 共享资源

   > 一台电脑多个用户
   >
   > 一个银行存款余额，多个ATM机
   >
   > 嵌入式系统（机器人控制：手臂和手的协调）

2. 加速

   > I/O操作和计算可以重叠
   >
   > 多处理器：将程序分成多个部分并行执行

3. 模块化

   > 将大程序分解成小程序
   >
   > 使系统易于扩展



##### 不确定性问题

* 实例

  * 程序调用`fork()`来创建一个新的进程

    * 操作系统需要分配一个新的并且唯一的进程ID

    * 因此在内核中，这个系统调用会运行`new_pid = next_pid++;`

      > `next_pid`是共享的全局变量

    * 翻译成机器指令即汇编语言

      1. `LOAD next_pid Reg1`

         > 把`next_pid`加载到寄存器1

      2. `STORE Reg1 new_pid`

         > 把寄存器1中的内容存到`new_pid`中

      3. `INC Reg1`

         > 给寄存器1做加一操作

      4. `STORE Reg1 next_pid`

         > 把寄存器1中的内容存到`nex_pid`中

  * 假设两个进程并发执行

    > 如果`next_pid`等于100，那么其中一个进程得到的ID应该是100，另一个进程得到的ID应该是101，`next_pid`应该增加到102
    >
    > 在独立进程/线程执行过程中，上述语句不会出现问题，但在并行执行中则不然：

    ```ascii
    * 进程1                              * 进程2
                         |
    Load next_pid Reg1   |
    STORE Reg1 new_pid   |
                         |  上下文切换
                         ▼------------>|
                                       |  Load next_pid Reg1
                                       |  STORE Reg1 new_pid
                                       |  INC Reg1
                                       |  STORE Reg1 next_pid
                             上下文切换  |
                         |<------------▼
    Inc Reg1             |   
    STORE Reg1 next_pid  |
                         |
                         ▼ 
    * 得到100作为新的PID                   * 得到100作为新的PID
    ```

    > * 进程1执行完第二条汇编，就切换至第二个进程，完成四条汇编以后再切换至进程1，完成进程1剩余的两条汇编指令
    > * 由于进程1还没来得及给寄存器做加一操作，两个进程的`new_pid`都是100
    > * 表面上看似乎最终执行完后，Reg1中的`next_pid`更新到了102，但是**由于发生上下文切换，会将寄存器的状态保存在进程1的PCB中，**等进程1重新占用CPU时，再把PCB中的内容加载到CPU中，这就使得Reg1中的数据重新恢复成100，`next_pid`最终变成101
    >
    > **上下文切换**参见《7.8-7.11 线程》

* 期望：

  * 无论多个线程的指令序列怎样交替执行，程序都必须正常工作
    * 多线程程序具有不确定性和不可重现的特点
    * 不经过专门设计，调试难度很高
  * 不确定性要求并行程序的正确性
    * 先思考清楚问题，把程序的行为设计清楚
    * 切记着手编写代码，遇到问题再调试



___

### 相关概念

##### 竞态条件

* 竞态条件（Race Condition）
  * 系统缺陷：结果依赖于并发执行或者事件的顺序/时间
    * 不确定性
    * 不可重现



##### 原子操作

* 原子操作（Atomic Operation）

* 原子操作是指一次不存在任何中段或者失败的执行

  * 该执行成功结束或者根本没有执行
  * 并且不应该发现任何部分执行的状态

  > 即不可被打断，要么执行并且执行完毕，要么还没有执行，不存在只执行了一部分并且被打断的状态

* 实际上操作往往不是原子的

  * 有些看上去是原子操作，但实际上不是

    > 连`x++`这样的简单语句，实际上都是由3条指令构成的
    >
    > 有时候甚至连单条机器指令都不是原子的
    >
    > 如`Pipeline`，`super-scalar`，`out-of-order`，`page fault`

* 示例：

  > ![原子操作与不确定性](.\pics\9-1.png)



##### 临界区

* Critical section

* 临界区是指进程中的一段需要访问共享资源，并且当另一个进程处于相应代码区域时，不会被执行的代码区域

##### 互斥

* Mutual exclusion
* 当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源

##### 死锁

* Dead lock
* 两个或以上的进程，在相互等待完成特定的任务，而最终没法将自身任务进行下去

##### 饥饿

* Starvation
* 一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行



##### 锁

* Lock
* 多线程时用于强行限制资源访问的同步机制

##### 解锁

* Unlock

* 线程执行完指令后，释放之前取得的锁

##### 死锁

* Deadlock

* 线程被阻塞并等待一个永远不为真的条件

  > 如两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出



##### 示例-买面包

> 从[9.3 一些概念part2](https://www.bilibili.com/video/BV1js411b7vg?p=57)开始，老师用“AB两人检查冰箱中的面包，若无则前往购买”的例子讲解了上述概念，建议直接视频观看

* 假设一个抽象的锁的实现：
  * `Lock.Acquire()`：在锁被释放前一直等待，然后获得锁
  * `Lock.Release()`：解锁并唤醒任何在等待中的进程
  * 这些一定是原子操作：如果两个线程都在等待同一个锁，并且同时发现锁被释放了，那么只有一个能够获得锁
  * 保证只有一个进程在临界区中执行，只有当该进程离开临界区，另一个进程才可以访问临界区



___

### 临界区的属性

* **互斥**

  > 同一时间，临界区中最多存在一个线程

* **前进**（Progress）

  > 如果一个线程想要进入临界区，那么它最终会成功

* **有限等待**：是对Progress的进一步强化补充

  > 如果一个线程`i`处于入口区，那么在`i`的请求被接受之前，其他线程待在临界区的时间是有限制的

* **无忙等待**（可选）

  > 如果一个进程在等待进入临界区，那么在它可以进入之前会被挂起
  >
  > 即不会进入**忙等待**（busy-waiting）状态



___

### 禁用硬件中断的解决方法

* 禁用中断：没有中断就没有上下文切换，因此没有并发

  * 硬件将中断处理延迟到中断被启用之后
  * 大多数现代计算机体系结构都提供指令来完成
  * 进入临界区时，禁用中断
  * 离开临界区时，重新启用中断

* 缺点：

  * 一旦中断被禁用，线程就无法停止

    > 中断最主要用来响应外部事件，与外设即时交互，如网络包传输、磁盘读写，如果屏蔽中断会影响这些事件的响应

    * 整个系统都会因该线程停下来
    * 可能导致其他线程处于饥饿状态

  * 要是临界区可以任意长怎么办

    * 无法限制响应中断所需的时间（可能存在硬件影响）

  * 多CPU情况下，一个CPU屏蔽中断指令但其他CPU还是会继续产生中断，因此仅限于单处理器



___

### 基于软件的解决方法

##### 问题抽象

* 两个线程`T0`和`T1`

* `Ti`的通用结构

  ```ascii
  do {
      enter section     //进入临界区
          critical section  //临界区
      exit section      //离开临界区
          remainder section //剩余区
  } while (1);
  ```

* 线程可能共享一些共有的变量来同步他们的行为



##### 缺陷解法一

* 共享变量初始化：`int turn = 0`

  * `turn == i`：表示应该谁进入临界区

* `Ti`的通用结构

  ```c
  do {
      while (turn != i);   //当turn不等于i时无限循环，直到等于i才跳出
      critical section;    //临界区
      turn = j;            //将turn设置成另一个线程的标号
      remainder section;   //剩余区
  } while (1);
  ```

* 满足互斥，但是有时不满足`Progress`（前进）

  * `Ti`做其他的事情，`Tj`想要继续运行，但是必须等待`Ti`处理临界区

    > `T1`首次执行临界区后将turn设为0，但如果后续`T0`不再执行临界区相关的代码，turn就不会被`T0`设置为1，`T1`后续想要再访问临界区就会无限等待



##### 缺陷解法二

* 共享变量初始化： `int flag[2];`，` flag[0] = flag[1] = 0;`

  * `flag[i] == 1`：指示进程是否准备好进入临界区

* `Ti`的通用结构

  ```c
  do {
      while (flag[j] == 1); //谦让处理，如果对方进程进入临界区，当前进程就死循环
      flag[i] = 1;          //当前进程要进入临界区，将自己标识设为1
      critical section;     //临界区
      flag[i] = 0;          //当前进程要离开临界区，将自己标识设为0
      remainder section;    //剩余区
  } while (1);
  ```

* 可以满足`Progress`，但是不满足互斥

  > 考虑一种情况：`T0`执行到第二行`while`语句后进行了一次上下文切换，`T1`也执行到第二行，此时`T0`和`T1`都把自身标识设为1，同时访问临界区，而没有满足互斥



##### 缺陷解法三

> 将解法二中的`flag[i] = 1;`放到第一步执行

* 共享变量初始化： `int flag[2];`，` flag[0] = flag[1] = 0;`

  * `flag[i] == 1`：指示进程是否准备好进入临界区

* `Ti`的通用结构

  ```c
  do {
      flag[i] = 1;          //当前进程要进入临界区，将自己标识设为1
      while (flag[j] == 1); //谦让处理，如果对方进程进入临界区，当前进程就死循环
      critical section;     //临界区
      flag[i] = 0;          //当前进程要离开临界区，将自己标识设为0
      remainder section;    //剩余区
  } while (1);
  ```

* 可以同时满足互斥和Progress，但是会造成死锁

  > 考虑一种情况，`T0`执行到第二行，将自身标号设为1，发生一次上下文切换，`T1`也执行到第二行将自身标号设为1，此时两个进程都陷入死循环



##### Peterson算法

* 使用两个共享数据项：

  * `int turn;`：指示该谁进入临界区

  * `boolean flag[];`：指示进程是否准备好进入临界区

  * 进入临界区代码：

    ```c
    flag[i] = TRUE;
    turn = j;
    while (flag[j] && turn == j); //flag[j]为真并且turn为j时，死循环等待
    ```

  * 退出临界区代码：

    ```c
    flag[i] == FALSE;
    ```

* `Ti`的通用结构

  ```c
  do {
      flag[i] = TRUE;
      turn = j;
      while (flag[j] && turn == j); //flag[j]为真并且turn为j时，死循环等待
      critical section;
      flag[i] == FALSE;
      remainder section;
  } while (TRUE);
  ```

* 可以使用反证法证明互斥，有限等待和Progress（前进）这三个属性得到满足

  > 如果两个进程都在临界区，turn == i且turn ==j，矛盾



##### Dekker算法

> 课后了解

* 同样使用`turn`和`flag[]`两种标识，但是比peterson算法更复杂

* `Ti`的通用结构

  ```c
  do {
      flag[i] =TRUE;
      while (flag[j] == TRUE) {
          if (turn != i) {
              flag[i] = FALSE;
              while (turn != i){};
              flag[i] = TRUE;
          }
      }
      critical section;
      turn = j;
      flag[i] = FALSE;
      remainder section;
  } while (TURE);
  ```

  

##### Bakery算法（n个进程）

> 课后了解
>
> 对n个进程的，还有Eisenberg and McGuire's Algorithm

* N个进程的临界区：

  * 进入临界区前，进程接受一个数字
  * 得到的数字最小的进程进入临界区
  * 如果进程`Pi`和`Pj`收到相同的数字，如果`i<j`则`Pi`先进入临界区，否则`Pj`先进入临界区
  * 编号方案总是按照枚举的增加顺序生成数字

  

##### 软件解决方案小结

* Dekker算法（1965）：第一个针对双线程例子的正确解决方案

* Bakery算法（Lamport 1979）：针对n线程的临界区问题的解决方案

* 缺陷：

  * 复杂：需要两个进程间的共享数据项

  * 需要**忙等待**：浪费CPU时间

  * 没有硬件保证的情况下没有真正的软件解决方案

    > Peterson算法需要原子的`LOAD`和`STORE`指令



___

### 基于硬件原子操作的高层抽象实现

##### 锁的抽象

* 锁是一种抽象的数据结构
  * 一个二进制状态（锁定/解锁），包含两种方法
  * `Lock.Acquire()`：在锁被释放前一直等待，然后获得锁
  * `Lock.Release()`：解锁并唤醒任何在等待中的进程

* 使用锁来编写临界区：

  ```ascii
  lock_next_pid -> Acquire();
  new_pid = next_pid++ ;
  lock_next_pid -> Release();
  ```

  > 如何在计算机中真正实现？



##### 实现互斥的特殊原子操作

* 大多数现代体系结构都提供特殊的原子操作指令：

  > * 通过特殊的内存访问电路
  > * 针对单处理器和多处理器

  1. `Test-and-Set`：测试和置位

     * 从内存中读取值
     * 测试该值是否为`1`，并返回`真`或`假`
     * 内存值设为`1`

     ```c
     boolean TestAndSet (boolean *target)
     {
         boolean rv = *target;
         *target = TRUE;
         return rv;
     }
     ```

  2. `Exchange`：交换

     * 交换内存中的两个值

     ```c
     void Exchange (boolean *a, boolean *b)
     {
         boolean temp = *a;
         *a = *b;
         *b = temp;
     }
     ```

* 虽然这两个指令的语义是由多个小步骤组成的，但他们已经被封装成一个机器指令

  * **执行这个机器指令的期间不允许中断，不会发生上下文切换**
  * 只有完成了整个指令的语义之后，才能发生中断
  * 因此**这两个指令都是原子操作**



##### Test-and-Set实现锁机制

* **忙等待**

  ```c
  class Lock {
      int value = 0;
  }
  
  Lock::Acquire(){
      while(test_and_set(value)); //spin
  }                               //value为0则直接跳出循环，并把value设为1 
                                  //value为1则忙等待，直到value变为0跳出循环
  Lock::Release(){
      value = 0;
  }
  ```

  * `Acquire()`
    * 如果锁处于释放状态，那么`test-and-set`读取0并将值设为1，表示锁设置为忙并且需要等待完成
    * 如果锁处于忙状态，那么`test-and-set`读取1并将值设为1，不改变锁的状态并且需要循环（自旋spin）
  * `Release()`
    * 释放锁后`value=0`，就会有一个等待的进程执行`Test-and-Set`而跳出循环进入临界区
  * 使用`忙等待`的锁：
    * 线程在等待的时候消耗CPU周期

* **无忙等待**：

  ```c
  class Lock {
      int value = 0;
      WaitQueue q;
  }
  
  Lock::Acquire(){
      while(test_and_set(value)) {
          add this TCB to WaitQueue q;
          schedule();
      }
  }
  
  Lock::Release(){
      value = 0;
      remove one thread t from q;
      wakeup(t);                   //唤醒操作
  }
  ```

* 当临界区很短，上下文切换的开销大于CPU忙等开销，则倾向于忙等实现方案

* 如果临界区很长，忙等占用CPU资源远远大于上下文切换的开销，则倾向于非忙等实现方案



##### Exchange实现锁机制

* 设置共享数据项`int lock = 0;`

* 线程`Ti`的通用结构（**忙等实现**）

  ```c
  int key;
  do {
      key = 1;
      while (key == 1) { exchange(lock, key) };
      critical section;
      lock = 0;         //其他等待的进程中，第一个做exchange的进程会进入临界区
      remainder section;
  }
  ```



##### 基于原子操作实现的优缺点

* 优点：
  * 适用于单处理器或共享主存的多处理器中**任意数量的进程**
  * 简单而且容易证明
  * 可以用于支持多临界区

* 缺点：
  * **忙等待**消耗处理器时间

  * 当进程离开临界区并且多个进程在等待时，可能导致**饥饿**

  * **死锁**

    > 如果一个低优先级的进程拥有临界区，并且一个高优先级的进程也需要，那么高优先级进程会获得处理器并等待临界区，而低优先级进程无法释放临界区
    >
    > > 可以通过优先级反转来解决，参见《8.1-8.6 调度》中的**优先级反转**





___

### 小结

* 锁是更高等级的编程抽象
  * 互斥可以使用锁来实现
  * 通常需要一定等级的硬件支持
* 常用的三种实现方法
  * 禁用中断（仅限于单处理器）
  * 软件方法（复杂）
  * 原子操作指令（单处理器或多处理器均可）
* 可选的实现内容：
  * 有忙等待
  * 无忙等待