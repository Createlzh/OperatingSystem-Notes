# 11.1-11.7 死锁

[TOC]

___

### 死锁问题

* 例：一组阻塞的进程`p1`持有一种资源`a`，等待获取另一个进程`P2`所占有的资源`b`；进程`p2`同样在阻塞状态，等待资源`a`；两个进程因为没法拿到需要的资源，永远无法执行完成并释放各自持有的资源

* 导致死锁的原因：并发进程



___

### 死锁的系统模型

* 死锁主要包括两个方面：资源方和资源需求方

* 资源类型`R1`，`R2`，…，`Rm`

  > 如CPU cycles，memory space，I/O devices

* 每个资源类型`Ri`有`Wi`个实例，即有`Wi`个`Ri`类型的资源

* 每个进程使用资源如下：

  * `request/get`：free resource

  * `use/hold`：requested/used resource

    > 此时被某个进程占用，其他进程无法访问

  * `release`：free resource

    > 使用之后释放资源

* 可重复使用的资源：
  * 在一个时间只能一个进程使用并且不能被删除
  * 进程获得资源，后来释放由其他进程重用
  * 资源类型包括：
    * 物理层面如处理器，I/O通道，主和副存储器，设备
    * 抽象层面如数据结构，文件、数据和信号量
  * 如果一个进程拥有一个进程并请求其他资源，且操作系统中还有其他类似的现象，死锁可能发生
* 使用资源：
  * 创建和销毁，如创建内存和释放内存
  * 在I/O缓冲区的中断，信号，消息，信息
  * 如果接收消息阻塞可能会发生死锁
  * 可能少见的组合事件会引起死锁

* **资源分配图**

  > 一组顶点`V`和边`E`的集合

  * 顶点`V`有两种类型：

    1. `P={P1, P2, ..., Pn}`，集合包括系统中的所有进程
    2. `R={R1, R2, ..., Rn}`，集合包括系统中的所有资源类型

  * 边`E`有两种类型：

    1. `Pi -> Rj`：一条从进程实例指向资源类型的边（requesting/claiming edge），表明该进程正在请求某个资源
    2. `Rj -> Pi`：一条从资源类型指向进程实例的边（assignment/holding edge），表明该资源类型中的一个实例被该进程所占有

  * 示例图1

    <img src=".\pics\11-1.png" alt="资源分配图1" style="zoom:50%;" />

    > 该示例图中，如果`P3`也在请求`R2`类型的资源，就可能会形成死锁
    >
    > 死锁的典型特征：形成了一个环，但有环的存在并不意味着一定有死锁

  * 示例图2

    <img src=".\pics\11-2.png" alt="资源分配图2" style="zoom:50%;" />

  * 基本结论：
    * 如果图中不包含循环，那么一定没有死锁
    * 如果图中包含循环：
      1. 如果每个资源类只有一个实例，那么死锁
      2. 如果每个资源类有几个实例，可能死锁



___

### 死锁的特征

* 死锁可能出现，如果四个条件同时成立：

  > 这是**必要条件**，但不是**充分条件**！

  1. **互斥**：在一个时间段内，只能有一个进程使用资源
  2. **持有并等待**：进程保持至少一个资源并且正在等待获取其他进程持有的额外资源
  3. **无抢占**：一个资源只能被进程资源释放，即在进程已经完成了它的任务之后主动释放
  4. **循环等待**：存在等待进程集合`{P0, P1, ..., Pn}`，`P0`正在等待`P1`所占用的资源，`P1`正在等待`P2`所占用的资源，…，`P(n-1)`正在等待`Pn`所占用的资源，`Pn`正在等待`P0`所占用的资源



___

### 死锁处理办法

* 四种方法：

  1. 死锁预防（Deadlock prevention）
  2. 死锁避免（Deadlock avoidance）
  3. 死锁检测（Deadlock detection）
  4. 死锁恢复（Recovery from Deadlock）

* 理想状态：

  * 确保系统永远不会进入死锁状态，但往往需要很多约束，导致功能受到很多限制

  * 操作系统运行进入死锁状态，然后也能恢复，但恢复死锁的开销太大

  * 忽略这个问题，假装系统中从来没有发生死锁

    > 用于大多数操作系统，包括UNIX

    

#### 死锁预防

* 基本思路：让死锁产生的四个必要条件之一得不到满足

  1. 互斥条件

     * 资源从互斥变为不互斥

     * 但是不满足互斥，会带来进程执行结果的不确定性，这是不可接受的

  2. 占用并等待

     * 必须保证当一个进程请求资源时，它不持有任何其他资源
     * 即进程在开始执行前请求分配所有资源，或者执行过程中只能在没有资源的状态下请求资源
     * 资源利用率低，可能发生饥饿

  3. 无抢占

     * 当一个进程占有某些资源并且请求其他不能立即分配的资源时，占用该资源的进程被杀死，就可以将资源抢占
     * 被抢占的资源添加到资源列表中，该进程能获得旧有的资源和它请求的新的资源，因此可以得到执行

  4. 循环等待

     * 对所有资源类型进行排序，并要求每个进程按照资源的顺序进行申请
     * 例如按照资源的递增或者递减的顺序申请
     * 在通用操作系统中使用较少，而在嵌入式系统中较多，因为资源类型有限



#### 死锁避免

* 比死锁预防的约束更宽松，需要系统具有一些额外的先验信息提供

  * 最简单最有效的模式是要求每个进程声明它可能需要的每个类型资源的最大数目
  * 资源的分配状态：
    * 通过限定提供与分配的资源数量
    * 进程的最大需求

* 死锁避免算法**动态检查**的资源分配状态，以确保永远不会有一个环形等待状态

  > 死锁预防是在进程执行前就进行检查，而死锁避免是动态检查

  * 当一个进程请求可用资源时，系统必须判断立即分配能否使得系统处于安全状态

* **系统处于安全状态**：针对所有进程，存在安全序列

* 序列`<P1, P2, ..., Pn>`是**安全**的：针对每个`Pi`，`Pi`要求的资源能够由当前可用的资源+所有的`Pj`持有的资源来满足，其中`j<i`

  * 如果`Pi`资源的需求不是立即可用，那么`Pi`可以等到所有的`Pj`完成
  * 当`Pi`完成后，`P(i+1)`可以得到所需要的资源，执行，返回所分配的资源并终止
  * 用同样的方法，`P(i+2)`，…，`Pn`可以获得其所需要的资源

* 死锁与安全状态：
  * 系统处于安全状态，则一定不会有死锁
  * 系统处于不安全状态，则可能会有死锁，即`unsafe`包含`deadlock`
  * 避免死锁：确保系统永远不会进入到不安全状态



##### 死锁避免的银行家算法

* **Banker's Algorithm**：死锁避免的著名算法

  > 银行系统中，客户完成项目需要申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求并且完成项目时，客户应该及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。

* 前提条件
  * 多个实例
  * 每个进程必须能最大限度地利用资源
  * 当一个进程请求一个资源，就不得不等待
  * 当一个进程获得所有的资源就必须在一段有限的时间释放它们

* 算法数据结构
  * `n`为**进程数量**，`m`为**资源类型数**
  * `Max`为**总需求量**，是`n*m`维矩阵：`Max[i,j] = k`表示进程`Pi`最多需要资源类型`Rj`的`k`个实例
  * `Available`为**剩余空闲量**，是长度为`m`的向量：如果`Available[j]=k`，有`k`个类型`Rj`的资源实例可用
  * `Allocation`为**已分配量**，是`n*m`维矩阵：`Allocation[i,j] = k`表示进程`Pi`当前已经分配了`k`个资源类型`Rj`的实例
  * `Need`为**未来需要量**，是`n*m`维矩阵，`Need[i,j] = k`表示进程`Pi`可能还需要至少`k`个资源类型`Rj`的实例来完成任务
  * `Need[i,j] = Max[i,j] - Allocation[i,j]`

  > * `Request[i,j]`是`n*m`维矩阵，`Request[i,j]=k`表示进程`Pi`正在请求k个资源类型`Rj`的实例
  > * `Finish[i]`是长度为`n`的向量，代表各个进程是否完成



##### 安全状态估计算法

* Safety State Estimating Algorithm

  > 个人理解：这个算法就是用来评估当前系统是否处于安全状态的算法

* 算法步骤

  1. 初始化

     > `Work`和`Finish`分别是长度为`m`和`n`的向量

     ```C
     Work = Available;//当前资源剩余空闲量
     Finish[i] = false for each process-i //表示每个线程都没有结束，i=0,1,...,n-1
     ```

  2. 找到这样的`i`，使得其满足如下两个条件：

     > 找到`Need[i]`比`Work`小且还没有完成的进程

     * `Finish[i] = false`
     * `Need[i] <= Work`
     * 如果没有满足条件的`i`，则转到步骤4

  3. 如果找到了满足条件的`i`

     ```C
     Work = Work + Allocation[i] //表示进程执行完毕之后将该进程的资源回收
     Finish[i] = true //将进程标记为已完成状态
     ```

     * 跳转到步骤2

  4. 如果对所有的`i`，都有：

     * `Finish[i] = true`，即说明针对`i`个进程，存在安全序列
     * 那么这个系统已经处于安全状态
     * 否则这个系统为不安全状态

  

##### 银行家算法

* Banker's Algorithm

* 算法步骤：

  * 初始化：`Request[i,j]`是`n*m`维矩阵，`Request[i,j]=k`表示进程`Pi`正在请求k个资源类型`Rj`的实例

  1. 如果`Request[i] <= Need[i]`，则转到步骤2，否则提出错误条件，因为进程已经超过了其最大要求

     > `Request[i] > Need[i]`即说明`Request[i] + Allocation[i] > Max[i]`

  2. 如果`Request[i] <= Available`，则转到步骤3，否则`Pi`必须等待，因为资源不可用

     > 假如`Request[i] > Available`，此时`Request[i] + Allocation[i] <= Max[i]`，但是由于当前资源不足，需要等待

  3. 假装给`Pi`分配它需要的资源：

     ```C
     //生成一个需要判断状态是否安全的资源分配环境
     Available = Available - Request[i];
     Allocation[i] = Allocation[i] + Request[i];
     Need[i] = Need[i] - Request[i];
     ```

  4. 调用安全状态估计算法（Safety State Estimating Algorithm）

     * 如果返回`safe`，那么将资源分配给`Pi`
     * 如果返回`unsafe`，则`Pi`必须等待，旧的资源分配状态被恢复



##### 死锁避免实例

* 安全状态实例
  * 初始状态

    > ![初始状态](.\pics\11-3.png)

  * 由于`P2`需要的`Need[2]`小于`Available`，所以

    >![P2-runs-to-completion](.\pics\11-4.png)

  * 同理，接下来可以执行`P1`，随后无论`P3`还是`P4`都能够执行了

  * 因此存在安全序列，整个系统处于安全状态

* 不安全状态实例

  * 初始状态

    >![初始状态](.\pics\11-5.png)

  * 此时`P1`请求一个`R1`类型的实例和一个`R3`类型的实例

    > 假装给`P1`分配资源，生成一个需要判断状态是否安全的资源分配环境
    >
    > ![P1-requests-one-unit-each-of-R1-and-R3](.\pics\11-6.png)

  * 由于给`P1`分配资源会导致系统进入不安全状态，因此`P1`需要等待



#### 死锁检测

* 条件相比于死锁避免进一步放宽：
  * 允许系统进入死锁状态
  
  * 死锁检测算法，判断系统是否有死锁
  
    > 死锁避免中，每次进程请求资源时都会判断系统是否处于安全状态，不允许系统进入不安全状态；
    >
    > 而死锁检测不是在每次发出请求时做判断，挪后到系统运行中的某个特定时间做检测和判断
  
  * 系统有死锁的话，启动恢复机制



##### 等待图检测

* 将资源分配图简化，去掉所有资源节点，只留下进程节点，变为进程等待图

  > **资源分配图**参见[死锁的系统模型](#死锁的系统模型)

* 如果一个进程`Pi`请求的资源被另一个进程`Pj`占有，则用一条连线表示`Pi`等待`Pj`：`Pi -> Pj`

* 定期调用检测算法来搜索图中是否存在循环
* 算法需要`n^2`次操作，`n`是途中顶点的数目



##### 基于安全状态判断的检测算法

* 算法数据结构

  * `n`为**进程数量**，`m`为**资源类型数**
  * `Available`为**剩余空闲量**，是长度为`m`的向量：如果`Available[j]=k`，有`k`个类型`Rj`的资源实例可用
  * `Allocation`为**已分配量**，是`n*m`维矩阵：`Allocation[i,j] = k`表示进程`Pi`当前已经分配了`k`个资源类型`Rj`的实例
  * `Request[i,j]`是`n*m`维矩阵，`Request[i,j]=k`表示进程`Pi`正在请求k个资源类型`Rj`的实例
  * `Finish[i]`是长度为`n`的向量，代表各个进程是否完成

* **死锁检测算法**

  1. 初始化

     ```C
     Work = Available;//当前资源剩余空闲量
     For each i:
     	if (Allocation[i] > 0) {
             Finish[i] = false; //表示线程没有结束
         } else {
             Finish[i] = true; //无分配资源则标记为true
         }
     ```

   2. 找出这样的索引：

      * `Finish[i] = false`

      * `Request[i] <= Work`

        > 线程没有结束并且请求的资源量小于当前的空闲资源量

      * 如果没有满足条件的`i`，则转到步骤4

  	3. 如果找到了满足条件的`i`

      ```C
      Work = Work + Allocation[i] //表示进程执行完毕之后将该进程的资源回收
      Finish[i] = true //将进程标记为已完成状态
      ```

      * 跳转到步骤2

  	4. 如果对部分`i`：

      * 有`Finish[i] == false`，则系统处于死锁状态
      * 进程`Pi`死锁

* 算法需要`O(m * n^2)`次操作来检测系统是否处于死锁状态

  * 开销很大，与银行家算法类似，如果定期执行的话开销过大，因此往往在系统调试时才用到
  * 银行家算法需要提前知道每个进程需要的最大资源数是多少，这一信息对很多程序来说很难获得

* 检测算法的使用：
  * 何时以及使用频率取决于：
    * 死锁多久可能会发生
    * 多少进程需要被回滚（one for each disjoint cycle）
  * 如果检测算法多次被调用，有可能是资源图有多个循环，所以我们无法分辨出多个可能死锁进程中的哪些进程造成死锁
  * 因此更多用在开发阶段，判断系统是否正确



#### 死锁恢复

* 法一：终止所有的死锁进程，但过于暴力
* 法二：在一个时间内终止一个进程直到死锁消除
* 终止进程的顺序应该是：最小成本
  * 进程的优先级
  * 进程运行了多久以及需要多少时间才能完成
  * 进程占用的资源
  * 进程完成需要的资源
  * 多少进程需要被终止
  * 进程是交互还是批处理

* 回滚：返回到一些安全状态，重启进程到安全状态
* 饥饿：同一进程可能一直被选作受害者，包括回滚的数量

